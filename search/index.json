[{"content":"文本 通过{{}}可以将Vue的数据插入网页中\n通过v-once可以让其中的数据只进行一次渲染，不会随着数据更新而更改，如\u0026lt;p v-once\u0026gt;{{person.name}}\u0026lt;/p\u0026gt;。\n显示原生 HTML 代码 通过v-html=varname实现将变量varname当作html代码来渲染。\n属性绑定 通过v-bind可以实现将html元素的属性（如class属性）与Vue对象的变量（可以是响应式变量）进行绑定：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script setup name=\u0026#34;App\u0026#34;\u0026gt; let classname = \u0026#34;main\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;!-- 通过 v-bind 才可以绑定 vue 的变量--\u0026gt; \u0026lt;div v-bind:class=\u0026#34;classname\u0026#34;\u0026gt;粉红色的回忆\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;style scoped\u0026gt; .main { background-color: pink; } \u0026lt;/style\u0026gt; 同时也可以通过更省略的语法绑定：\n1 2 3 4 \u0026lt;template\u0026gt; \u0026lt;!-- 将 v-bind:class= 省略为 :class= --\u0026gt; \u0026lt;div :class=\u0026#34;classname\u0026#34;\u0026gt;粉红色的回忆\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 使用 JS 表达式 在使用了v-bind和{{}}的地方可以使用JS表达式（不能是语句），例如：\n1 2 3 4 5 6 7 \u0026lt;script setup name=\u0026#34;App\u0026#34;\u0026gt; let temp = 19; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt;{{ temp\u0026gt;18?\u0026#39;出去玩\u0026#39;:\u0026#39;回家睡觉\u0026#39; }}\u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; 条件判断 模板可以根据条件选择进行渲染，提供的语法为：v-if、v-else-if、v-else组合实现条件判断。\n模板也提供v-show=”true“选择是否渲染内容。\nv-show与v-if的区别在于是否加载到网页中，v-show的内容无论是否渲染，都加载到网页中，只是不渲染而已；v-if只有在第一次条件为真时，才会加载到网页中。\n循环 在模板中可以使用v-for实现对Vue中的对象、数组进行遍历等操作。\n对于数组 1 2 3 4 5 6 \u0026lt;!-- book为数组遍历的返回，index为索引号（0开始），变量名均可自定义 --\u0026gt; \u0026lt;tr v-for=\u0026#34;(book, index) in books\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{ index }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ book.title }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ book.author }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; 对于对象 1 \u0026lt;div v-for=\u0026#34;(value, key) in books\u0026#34;\u0026gt;{{ key }}:{{ value }}\u0026lt;/div\u0026gt; 保持一致 通过循环得到的HTML标签，在没有使用key属性标记时，若是数据发生改变（如顺序改变），默认标签会重用，只是数据会改变，即HTML代码不变，只有{{}}中的内容会改变，但在同一循环的input等标签不会随着改变。\n若想保持一致，如下：\n1 2 3 4 5 \u0026lt;!-- 循环所产生的 HTML 标签绑定到对应的 key 上--\u0026gt; \u0026lt;div v-for=\u0026#34;(book, index) in books\u0026#34; v-bind:key=\u0026#34;book.name\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;book\u0026#34;\u0026gt;{{ book }}\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-bind:placeholder=\u0026#34;book\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; 会触发视图更新的数组操作 push()：添加元素的方法 pop()：删除数组最后一个元素 shift()：删除数组的第一个元素 unshift(item)：在数组的开头位置添加一个元素 splice(index,amount,item1,...,itemX)：向数组中index删除amount个元素，添加元素item1,...,itemX sort(function(x,y))：排序，自定义一个function，若运算后返回不小于 0，则x在前，反之y在前 reverse()：将数组元素进行反转 事件绑定 基本使用 可以使用v-on实现绑定事件，如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;script setup name=\u0026#34;App\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34; let count = ref(0); const subtract = function (value){ count.value -= value; } const getevent = function (value,event){ const.value += value; console.log(event) } \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;p\u0026gt;{{ count }}\u0026lt;/p\u0026gt; \u0026lt;!-- 通过 v-on 绑定事件：count += 1 --\u0026gt; \u0026lt;button v-on:click=\u0026#34;count += 1\u0026#34;\u0026gt;加 1\u0026lt;/button\u0026gt; \u0026lt;!-- 使用 @事件 代替 v-on:事件 来绑定事件：subtract(10) --\u0026gt; \u0026lt;button @click=\u0026#34;subtract(10)\u0026#34;\u0026gt;减10\u0026lt;/button\u0026gt; \u0026lt;!-- 使用固定的 $event 传入事件的属性 --\u0026gt; \u0026lt;button @click=\u0026#34;getevent (10,$event)\u0026#34;\u0026gt;减10\u0026lt;/button\u0026gt; \u0026lt;/template\u0026gt; 事件修饰符 在绑定事件中，我们可以在绑定的函数中对事件进行操作，如阻止超链接的点击默认跳转，就可以在超链接绑定的函数中加入：\n1 2 // 需要传入 $event event.preventDefault(); 也可以采用更加简略的写法，直接在绑定时就实现（事件.prevent）：\n1 \u0026lt;a href=\u0026#34;https://www.baidu.com/\u0026#34; v-on:click.prevent=\u0026#34;gotoWebsite($event)\u0026#34;\u0026gt;百度\u0026lt;/a\u0026gt; 常见修饰符有：\n.stop：event.stopPropagation，阻止事件冒泡（事件发生后，会向外层标签发生通知，这就是冒泡） .capture：事件捕获 .once：这个事件只执行一次 .self：代表当前这个被点击的元素自身 .passive：在页面滚动的时候告诉浏览器不会阻止默认的行为，从而让滚动更加顺畅 v-model 想让表单元素（如常见的输入框input）实现响应式变量（用户对表单的修改实时的反映到变量上），就可以使用v-model实现绑定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;script setup\u0026gt; import {ref} from \u0026#34;vue\u0026#34;; let username = ref(\u0026#34;\u0026#34;); let category = ref(0); \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 对 input 的修改会实时反应到 username 上 --\u0026gt; \u0026lt;input v-model=\u0026#34;username\u0026#34; /\u0026gt; \u0026lt;p\u0026gt;用户名为：{{username}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;select v-model=\u0026#34;category\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;1\u0026#34;\u0026gt;Python\u0026lt;/option\u0026gt; \u0026lt;option value=\u0026#34;2\u0026#34;\u0026gt;前端\u0026lt;/option\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;p\u0026gt;分类为：{{category}}\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; ","date":"2024-08-16T11:57:52+08:00","permalink":"https://llwh2333.github.io/p/%E6%A8%A1%E6%9D%BF%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","title":"模板常用语法"},{"content":"什么是响应式变量 所谓的响应式变量就是指变量的值发生改变的时候，依靠这个变量所渲染的视图也会发生改变。具体一点讲就是：\n1 2 3 4 5 const count = ref(0); function Upcount() { count.value++; } 1 2 3 \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;Upcount\u0026#34;\u0026gt;Count：{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; 按照上面这段代码，当count变量被函数Upcount修改时，展示的页面并不需要刷新，count变量自然会被修改，并不需要重新加载一遍count这个变量展示页面才会修改具体的count。\n声明的响应式变量 声明响应式变量在Vue3中有两种方法：ref()函数和reactive()函数，前者可以定义基本类型变量（数值型、字符串等）和复合型变量（字典类型等），后者只能定义复合型变量。\n具体讲：\n定义基本数据类型，必须使用ref() 定义层级不深的复合数据类型，可以使用ref()和reactive() 定义层级很深的符合数据类 ing，推荐使用reactive() ref 声明 可以通过let varname = ref(初始值)声明一个响应式变量，同时其使用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;!-- 在模板中直接访问变量的名称即可 --\u0026gt; \u0026lt;button @click=\u0026#34;Upcount\u0026#34;\u0026gt;Composition Count：{{ count }}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup name=\u0026#34;Compositionname\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const count = ref(0); function Upcount() { // 在 script 中，需要使用 变量名.value 进行访问，如果是复合型使用 变量名.value.字段名 访问 count.value++; } \u0026lt;/script\u0026gt; reactive 声明 可以通过let varname = reactive(初始值)声明一个响应式变量，同时其使用如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button @click=\u0026#34;Update\u0026#34;\u0026gt;Var content: {{ count.name }}\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;UpdataAll\u0026#34;\u0026gt;All filed change:{{ count.name }}\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script setup name=\u0026#34;ReactiveVar\u0026#34;\u0026gt; import { reactive } from \u0026#34;vue\u0026#34;; // 声明一个复合类型响应式变量 let count = reactive({ name: \u0026#34;reactive var\u0026#34;, age: 1888, }); function Update() { // 更新其中一个字段 count.name = \u0026#34;update reactive var\u0026#34;; } const UpdataAll = () =\u0026gt; { // 更新整个变量 // 不使用 Object.assign 而是直接赋值，如： // count = { name: \u0026#34;all updata reactive\u0026#34;, age: 12222} 会失去响应式 Object.assign(count, { name: \u0026#34;all updata reactive\u0026#34;, age: 12222 }); }; \u0026lt;/script\u0026gt; 深入一些理解两者 reactive 对于ractive()返回的其实是原始对象的Proxy，两者并不是相等的（对于===比较返回的是false）。\n为了保证访问Proxy的一致性，对于同一个原始对象调用reactive()返回的Proxy是已存在的本身，对于多层级的对象依旧是同一个。\n对于reactive的响应式变量的属性赋值或者解构到本地变量，将会失去响应性的连接：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const varname = reactive({name:\u0026#34;aaa\u0026#34;,age=18}); let n = varname.age; // varname.age 不会受到影响 // 且 n 不是响应式变量 n++; let {count} = state // varname.age 不会受到影响 // 且 count 不是响应式变量 count ++ function ChangeLocalVar(localage) { // 不会影响 varname.age localage++; } ref 对于一个ref的的响应式变量，当传入的参数为基本数据类型时，返回一个基本类型的ref对象，而对于一个复合类型参数，会使用reactive()处理。\n对于复合类型的ref对象，可以整个的替换，如下：\n1 2 3 4 5 let Person = ref({name = \u0026#34;aaa\u0026#34;,age=18}) function (){ Person.value = ref({name = \u0026#34;bbb\u0026#34;,age=1}) } 在Vue中提供两种方法读取ref对象：.value和unref()。前者不用讲了，后者对于输入的参数，如果是ref对象，则返回.value的值，否则返回参数本身。\n当ref对象在模板中作为顶层（如let person = ref({ age:22 });）被访问时，会自动解包访问值，同时可以进行计算如：{{Person.age + 1}}，但对于非顶层的ref（如let person = { age: ref(22) };），可以自动解包展示，但不能进行计算（如{{Person.age + 1}}），计算会显示为[object Object]1。\n响应式原理 Vue2 在Vue2中，响应式是通过Object.defineProperty()方法实现，其本身会对输入的data进行遍历，将其中的所有属性转换为getter/setter，当数据发生变化，就会自动触发相应的getter/setter函数，来更新视图。\n其缺点在于：\n只会对初始化时存在的对象属性进行监听，如果新增属性，则不具有响应式，即监听不到。 对于数组，是通过覆盖原型对象上的 7 个方法（push、pop、shift、unshift、splice、sort、reverse）实现的，直接修改下标进行修改数据同样是监听不到 无法处理Map、Set这种集合类型数据 Vue3 Vue3的响应式是基于SE6的proxy的方法实现的。在其中的track()函数，会追踪所有依赖了该属性的，收集起来放在一个Set()中，如果后续属性有变化，就通过trigger()通过对应Set()函数中对应视图更新一遍。对于基本数据类型，放在Set()中，而复合类型，通过将基本类型的Set()放在Map()中。此外，还有其他的一些，但确实不是很明白，就留待补充了。\n参考文章 前端 - 全方位带你掌握 ref、reactive，开启 Vue3 响应式的大门！ - 个人文章 - SegmentFault 思否\njavascript - 林三心画了 8 张图，最通俗易懂的 Vue3 响应式核心原理解析 - 个人文章 - SegmentFault 思否\n","date":"2024-08-16T01:03:19+08:00","permalink":"https://llwh2333.github.io/p/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8F%98%E9%87%8F/","title":"响应式变量"},{"content":"选项式 API （Options API）式在Vue2中使用的，对于Vue3，其同样兼容选项式 API，但推荐的使用方法是组合式 API（Composition API）。\n选项式 API 选项式 API 的形式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;script\u0026gt; export default { // 定义选项式 API 的组件名称 name: \u0026#34;Options\u0026#34;, // 变量存在在 data 函数返回 // data() 返回的属性将会成为响应式的状态 // 并且暴露在 `this` 上(methods 中通过 this.变量 调用) data() { return { count: 0, }; }, // 方法放在 methods 中 // methods 是一些用来更改状态与触发更新的函数 // 它们可以在模板中作为事件处理器绑定 methods: { Upcount() { this.count++; }, }, }; \u0026lt;/script\u0026gt; 使用该组件：\n1 2 3 4 5 6 7 \u0026lt;script setup\u0026gt; import Options from \u0026#34;./components/Options.vue\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;template\u0026gt; \u0026lt;Options\u0026gt;\u0026lt;/Options\u0026gt; \u0026lt;/template\u0026gt; 组合式 API 组合式 API 如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;script\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; export default { // 定义组合式 API 的组件名称 name: \u0026#34;Composition\u0026#34;, // 选项式 API 定义的数据、方法、计算属性、监听等数据均在 setup 中 setup() { // 变量均为响应式状态 const count = ref(0); function Upcount() { count.value++; } return { count, Upcount, }; }, }; \u0026lt;/script\u0026gt; 此外Vue3还存在一个setup语法糖：\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const count = ref(0); function Upcount() { count.value++; } \u0026lt;/script\u0026gt; setup 组件名称 setup 组件名称默认为文件名称。\nexport default 在组合式 API 中第一种定义方法可以在export default中直接通过name定义组件名称\nscript 可以另起一个script标签定义名称\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;script\u0026gt; export default { name: \u0026#34;Composition\u0026#34;, }; \u0026lt;/script\u0026gt; \u0026lt;script setup\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const count = ref(0); function Upcount() { count.value++; } \u0026lt;/script\u0026gt; 插件 通过安装vite-plugin-vue-setup-extend可以在script setup上命名组件名称。\n首先npm install vite-plugin-vue-setup-extend --save-dev（开发中使用，所以放在dev中）。\n然后在vite.config.js中添加：\n1 2 3 4 5 6 7 8 9 10 11 import VueSetupExtend from \u0026#34;vite-plugin-vue-setup-extend\u0026#34;; // https://vitejs.dev/config/ export default defineConfig({ plugins: [vue(), VueDevTools(), VueSetupExtend()], resolve: { alias: { \u0026#34;@\u0026#34;: fileURLToPath(new URL(\u0026#34;./src\u0026#34;, import.meta.url)), }, }, }); 最后我们就能在script setup上命名组件名称：\n1 2 3 4 5 6 7 8 9 \u0026lt;script setup name=\u0026#34;Compositionname\u0026#34;\u0026gt; import { ref } from \u0026#34;vue\u0026#34;; const count = ref(0); function Upcount() { count.value++; } \u0026lt;/script\u0026gt; ","date":"2024-08-15T15:58:59+08:00","permalink":"https://llwh2333.github.io/p/%E9%80%89%E9%A1%B9%E5%BC%8F-api-%E5%92%8C%E7%BB%84%E5%90%88%E5%BC%8F-api/","title":" 选项式 API 和组合式 API"},{"content":"Rust 之所有权 `Rust`中的所有权有如下规则： 每一个值都被其所有者变量所拥有\n值在任意时刻只能被一个所有者拥有\n当所有者离开作用域时，值将被丢弃\n我们知道Rust中变量的声明是通过let实现，这个行为称为绑定（我的理解是名义和实际是分开的）。对于基本类型（整数、浮点数、布尔、字符类型）的变量，其存储在栈（长度已知且固定的结构）中，而其他复杂的结构存放在堆（适合存放缺乏组织的数据结构）中。\n所有权的转移 对于基本数据类型，前后的绑定是通过自动拷贝（深拷贝）实现的，而对于复杂的数据类型（字符串类型、结构体等）是通过所有权转移实现的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 fn main() { let one_int = 333; println!(\u0026#34;var one_int{}\u0026#34;,one_int); let sec_int = one_int; // 基本数据类型， println!(\u0026#34;var sec_int{}\u0026#34;,sec_int); println!(\u0026#34;var one_int{}\u0026#34;,one_int); let s1 = String::from(\u0026#34;hello\u0026#34;); println!(\u0026#34;{}, world!\u0026#34;, s1); let s2 = s1; // s1 存储数据的所有权转移给了 s2，s1 便无法访问 println!(\u0026#34;{}, world!\u0026#34;, s2); // println!(\u0026#34;{}, world!\u0026#34;, s1); // 报错 } 借用 `Rust`中的借用就是指通过引用（使用`\u0026amp;`符号）的方法，获得数据的访问权，而不是所有权，同时分为可变借用（可以修改拥有访问权的变量）和不可变借用（不可修改）。 对于可变借用，每一个可变变量在同一作用域中只能存在一个可变借用。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s1); // s1 发生不可变借用，函数只能读取但不能修改 s1 println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s1, len); // 可变变量才可以进行可变借用 let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); // s 被可变借用，函数可以修改 s println!(\u0026#34;{}\u0026#34;, s); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { // s 是对 s1 的引用 s.len() } fn change(some_string: \u0026amp;mut String) -\u0026gt; \u0026amp;mut String{ some_string.push_str(\u0026#34;, wtf!\u0026#34;); some_string } 总的来说，同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用。 函数 `Rust`中函数使用关键字`fn`声明，每个`Rust`文件中默认入口函数为`main`函数（即默认执行函数`main()`）。 函数的返回值类型需要使用`-\u0026gt;`指定，函数的返回值可以通过最后一个表达式（如`a+1`，但注意不能用分号，不然就是语句了），或者使用`return`明确的返回。 1 2 3 4 fn add_two(a: i32) -\u0026gt; i32 { a + 2 // 或 return a + 2; } 控制流 `Rust`的控制流包含`if`表达式和循环控制。 `if`表达式和其它语言的很类似，就是基本的`if a == 1{} else if a == 2{} else{}`。 循环就主要有`loop`循环、`while`循环、`for`循环。 `loop`循环，可以通过`loop`关键字创建一个无限循环，可以通过条件表达式配合`break`跳出循环。 1 2 3 4 loop { println!(\u0026#34;again!\u0026#34;); break; // 无限循环，但这里我们立刻跳出循环 } `while`循环在后面条件为真时，循环执行。 1 2 3 4 5 6 let mut number = 3; while number != 0 { println!(\u0026#34;{}!\u0026#34;, number); number -= 1; } println!(\u0026#34;LIFTOFF!!!\u0026#34;); `for`循环可以遍历一个集合中的元素，如数组和范围（`1..=5`，表示1到5，加`=`就包含5，不加就不包含）。 1 2 3 4 5 6 7 8 let a = [10, 20, 30, 40, 50]; // 可变借用循环 for element in a.iter_mut() // 但 a 为不可变变量，所以会报错。 // 所有权转移循环 for element in IntoIterator::into_iter(a) // 不可变借用循环，如下 for element in a.iter() { println!(\u0026#34;the value is: {}\u0026#34;, element); } `Rust`可以通过`break`、`continue`进行循环控制，`break`为跳出当前循环，`continue`为跳过循环剩余部分。 集合 常用的集合类型有：`Vector`（数组）、`Hashmap`（字典）这两种类型。 Vector `Vector`是一个变长的数组，数组中元素类型相同。实际上在前面已经展示过其的使用了。 1 2 3 4 5 6 7 8 9 10 11 12 fn main() { // 1.显式声明动态数组类型 let mut v1: Vec\u0026lt;i32\u0026gt; = Vec::new(); v1.push(1); v1.push(2); v1.push(3); println!(\u0026#34;vector v1: {:?}\u0026#34;, \u0026amp;v1); // 2.使用宏 vec! 来创建数组，支持在创建时就给予初始化值 let v2 = vec![1u8, 2, 3]; println!(\u0026#34;vector v2: {:?}\u0026#34;, \u0026amp;v2); } 对其的访问与遍历通过`for`可以实现： 1 2 3 for i in \u0026amp;v { println!(\u0026#34;{}\u0026#34;, i); } Hashmap `HashMap`是一个可以存储键值对的集合，如同和`Java`的`HashMap`类似。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // hashmap 的使用需要导入 use std::collections::HashMap; fn main() { // 显式的创建一个 hashmap let mut myhashmap = HashMap::new(); // 插入键值对 myhashmap.insert (\u0026#34;aaa\u0026#34;,10); // 查看键值对 // get 查询到时返回一个 option\u0026lt;\u0026amp;i32 类型 if let Some(ans1) = myhashmap.get(\u0026#34;aaa\u0026#34;){ println!(\u0026#34;the result {}\u0026#34;,ans1); } // 更新键值对(覆盖) myhashmap.insert(\u0026#34;aaa\u0026#34;,20); if let Some(ans2) = myhashmap.get(\u0026#34;aaa\u0026#34;){ println!(\u0026#34;the updata1 result {}\u0026#34;,ans2); } // 更新键值对（查询后不存在才插入） let newans = myhashmap.entry(\u0026#34;aaa\u0026#34;).or_insert(30); println!(\u0026#34;the updata2 result {}\u0026#34;,newans); } ","date":"2024-08-12T04:23:59+08:00","permalink":"https://llwh2333.github.io/p/rust-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","title":"Rust 基础数据结构"},{"content":"Windows 下安装 在 RUSTUP-INIT 下载系统相对应的 Rust 安装程序\n直接执行 exe 程序（windows 尽量用 proxychain 这些代理跑，不然下载会很慢，还有可能断开），会弹出选择（这里我选择 3 ，因为并不想安装 VS 这玩意）\n选择 3 后，我们继续选择 2，进行自定义安装，然后如图输入\n然后重新回到选择界面，选择 1 ，进行安装，然后就安装好了\n然后就是配置环境变量，主要有：cargo和rustup这两个，具体位置在程序运行的开头部分有展示\n最后就安装好了\nVS code 插件 rust-analyzer\n","date":"2024-08-12T00:50:27+08:00","permalink":"https://llwh2333.github.io/p/rust-%E5%AE%89%E8%A3%85/","title":"Rust 安装"},{"content":"程序（合约）的交互 JS 交互 通过anchor库，可以实现调用其他程序中的方法，与查看程序中定义的PDA账户中的数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // 调用程序中的某个方法 // 导入相关库 // anchor 库更好的实现了程序方法的调用 const anchor = require(\u0026#34;@coral-xyz/anchor\u0026#34;); const { PublicKey } = require(\u0026#34;@solana/web3.js\u0026#34;); const { Buffer } = require(\u0026#34;buffer\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const connection = new anchor.web3.Connection(anchor.web3.clusterApiUrl(\u0026#34;devnet\u0026#34;), \u0026#34;confirmed\u0026#34;); // 加载钱包文件 function localwalletkey(keypairFile) { const fs = require(\u0026#34;fs\u0026#34;); const loaded = anchor.web3.Keypair.fromSecretKey( new Uint8Array(JSON.parse(fs.readFileSync(keypairFile).toString())) ); return loaded; } const keypair = localwalletkey(\u0026#34;$path\u0026#34;); const wallet = new anchor.Wallet(keypair); const provider = new anchor.AnchorProvider(connection, wallet, { preflightCommitment: \u0026#34;confirmed\u0026#34;, }); // 设置当前客户端的默认 provider anchor.setProvider(provider); // 调用其他程序的方法 async function callProgram() { // 加载相关的文件 const idl = JSON.parse(fs.readFileSync(\u0026#34;idl.json\u0026#34;)); const programid = new anchor.web3.PublicKey(\u0026#34;programID\u0026#34;); // 实例化程序 const program = new anchor.Program(idl, programid, provider); // 构建相关 PDA 地址 const [Pda] = anchor.web3.PublicKey.findProgramAddressSync([Buffer.from(\u0026#34;pda\u0026#34;)], programid); // methods.方法名(方法中除了账户外的参数).accounts({方法的账户参数}) // 方法名需要注意，并非与程序中定义（在seahorse框架下）的一致，而是驼峰写法 const txhash = await program.methods .transferSol(new anchor.BN(1000)) .accounts({ Sender: wallet, pda: Pda, }) .rpc(); console.log(\u0026#34;交易hash:\u0026#34;, txhash); // 此处的 program.account.账户名称 ，需要采用驼峰写法 const class_account = await program.account.pda.fetch(Pda); console.log(\u0026#34;pda data:\u0026#34;, class_account.owner); } callProgram(); Python 交互 1 2 3 4 5 6 7 8 9 10 11 12 from seahorse.prelude import * declare_id(\u0026#34;\u0026#34;) # Program 为一个程序类型 # callpda 为调用其他程序中涉及的 pda ，类型必定为UncheckedAccount @instruction def call_program(signer:Signer,callpda:UncheckedAccount ,program:Program,u:u64): # cpi调用 program.invoke(accounts=[ CpiAccount(callpda,mut=True) ],data = int_bytes(u)) ","date":"2024-08-10T23:07:57+08:00","permalink":"https://llwh2333.github.io/p/solana-%E4%B8%AD%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%BA%A4%E4%BA%92/","title":"Solana 中的程序的交互"},{"content":"这里主要就是通过程序发行的代币相关的交互。\nSPL（ERC20）代币的交互 在Solana中，可以官方提供了模板进行山寨币的创建，可以通过调用系统程序进行代币的创建。\nJS 交互 可以通过JS和SPL代币进行交互，包括了：代币的创建、铸币、查看账户中代币的余额、进行SPL代币转账、销毁持有的SPL\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 // 通过 js 创建 spl 、查看 spl 余额、进行 spl 转账、销毁 spl // 导入相关模块 const web3 = require(\u0026#34;@solana/web3.js\u0026#34;); const spltoken = require(\u0026#34;@solana/spl-token\u0026#34;); // 创建与 solana 的连接 const connection = new web3.Connection(web3.clusterApiUrl(\u0026#34;devnet\u0026#34;), \u0026#34;confirmed\u0026#34;); // 加载钱包文件 function localwalletkey(keypairFile) { const fs = require(\u0026#34;fs\u0026#34;); const loaded = web3.Keypair.fromSecretKey( new Uint8Array(JSON.parse(fs.readFileSync(keypairFile).toString())) ); return loaded; } // 创建一个 spl token async function createspl() { // 加载一个钱包，作为交易费用支付者 const pairkey = localwalletkey(\u0026#34;$key_path\u0026#34;); ////////////////// 创建中涉及的用户地址 ////////////////// // 交易费用支付者 const payer = pairkey; // 控制铸币的账户 const mintAuthority = pairkey.publicKey; // 可以冻结代币的账户（可选是否存在） const freezeAuthority = pairkey.publicKey; // 通过solana系统程序创建一个 spl 代币 const mint = await spltoken.createMint( // solana 连接 connection, payer, mintAuthority, freezeAuthority, // 代币的精度 9 ); console.log(\u0026#34;创建新SPLToken\u0026#34;, mint.toBase58()); } // 向指定账户进行铸币 async function minttoken(account) { // 需要铸币的 spl token 地址 const mint = new web3.PublicKey(\u0026#34;token_address\u0026#34;); // 支付交易费用者 const payer = localwalletkey(\u0026#34;$key_path\u0026#34;); // 拥有铸币权限的地址(因为是测试，所以地址为 payer) const mintAuthority = payer; // 接收 spl token 的地址 const recipient = account; // 获取接收者对应的 token 账户（获取或创建） const totokenaccount = await spltoken.getOrCreateAssociatedTokenAccount( connection, // 如果要创建账户，那么创建账户交易的支付者 payer, // token 账户对应 token mint, // 账户的所有者地址 recipient ); await spltoken.mintTo( connection, // 交易费用支付者 payer, // token 地址 mint, // 接收者 token 账户地址 totokenaccount.address, // 拥有铸币权限的地址 mintAuthority.publicKey, 100 * 1000000000 ); } // 查看指定账户的 spl 余额 async function catbalance(account) { // 需要监控的地址 const destination = account; // token 地址 const mint = new web3.PublicKey(\u0026#34;token_address\u0026#34;); const mintinfo = await spltoken.getMint(connection, mint); // 获取地址对应的 token 账户 const splaccount = await spltoken.getAssociatedTokenAddress(mint, destination, true); const accountinfo = await spltoken.getAccount(connection, splaccount); console.log(\u0026#34;token supply:\u0026#34;, mintinfo.supply); console.log(\u0026#34;account address:\u0026#34;, account.toBase58()); console.log(\u0026#34;token account Balance:\u0026#34;, accountinfo.amount); } // 向指定账户转账 spl async function transferspl() { // token 地址 mint = new web3.PublicKey(\u0026#34;token_address\u0026#34;); // 交易费用支付者 const payer = localwalletkey(\u0026#34;$key_path\u0026#34;); // 发送者公钥地址 const sender = payer.publicKey; const recipient = new web3.PublicKey(\u0026#34;$another_publikey\u0026#34;); const fromtoken = await spltoken.getAssociatedTokenAddress(mint, sender, true); const totoken = await spltoken.getOrCreateAssociatedTokenAccount( connection, payer, mint, // 账户的所有者地址 recipient ); let tx = spltoken.createTransferInstruction( fromtoken, totoken.address, sender, 1 * 1000000000, [], spltoken.TOKEN_PROGRAM_ID ); let transaction = new web3.Transaction().add(tx); let signature = await web3.sendAndConfirmTransaction(connection, transaction, [payer]); console.log(\u0026#34;交易哈希:\u0026#34;, signature); } // 销毁持有的一定数量的 spl 代币 async function burnspl(account) { // 交易费用支付者 const payer = account; // token 地址 const mint = new web3.PublicKey(\u0026#34;token_address\u0026#34;); // 获取地址对应的 token 账户 const splaccount = await spltoken.getAssociatedTokenAddress(mint, account.publicKey, true); let tx = spltoken.createBurnInstruction(splaccount, mint, account.publicKey, 0.1 * 1000000000); let transaction = new web3.Transaction().add(tx); let signature = await web3.sendAndConfirmTransaction(connection, transaction, [payer]); console.log(\u0026#34;交易哈希:\u0026#34;, signature); } async function main() { // await createspl(); const accounta = localwalletkey(\u0026#34;wallet-keypair.json\u0026#34;); const publicKeya = accounta.publicKey; const publicKeyb = new web3.PublicKey(\u0026#34;\u0026#34;); // 向地址 a 进行铸币 await minttoken(publicKeya); // 查看 a 余额 await catbalance(publicKeya); // a 向 b 转账 await transferspl(); // 查看 a 和 b 的余额 await catbalance(publicKeya); await catbalance(publicKeyb); await catbalance(publicKeya); // 销毁 a 中的一定数量的 spl 代币 await burnspl(accounta); await catbalance(publicKeya); } main(); Python 交互 python 的Seahorse很多资料没有，目前只能进行：查看 token 余额、转账\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from seahorse.prelude import * # 在程序中查看 token 余额、转账 declare_id(\u0026#34;\u0026#34;) class Program(Account): # 进行转账的 spl token 的地址 mint_addr:Pubkey # 存放 spl token 的账户 program_token_account:Pubkey @instruction def init_token_accout(token_account:Empty[TokenAccount],mint:TokenMint,signer:Signer,program:Empty[Program]): # 初始化程序的 token account token_account = token_account.init(payer=signer,seeds=[\u0026#39;token_account\u0026#39;],mint=mint,authority=signer) # 初始化并保存程序的账户 program = program.init(payer=signer,seeds=[\u0026#39;program\u0026#39;]) program.mint_addr = mint.key() program.program_token_account = token_account.key() # 将自己手中的 spl token 发送给程序的 token 账户 @instruction def spend_token(spender_token:TokenAccount,program_token_account:TokenAccount,signer:Signer,program:Program): # 检查用户提供的 spl token 是不是我们指定的 spl token assert str(spender_token.mint) == str(program.mint_addr),\u0026#34;token error\u0026#34; # 保证发送到的 token 账户，为指定的 token 账户 assert program_token_account.key() == program.program_token_account,\u0026#34;program token account error\u0026#34; spender_token.transfer(authority=signer,to=program_token_account,amount=10000000) # 取出程序中的 spl token @instruction def withdrawals(to_account:TokenAccount,program_token_account:TokenAccount,program:Program,signer:Signer): # 检查用户提供的 spl token 是不是我们指定的 spl token assert str(to_account.mint) == str(program.mint_addr),\u0026#34;token error\u0026#34; # 保证取出的 token 账户，为指定的 token 账户 assert program_token_account.key() == program.program_token_account,\u0026#34;program token account error\u0026#34; # 将程序的 token 账户中的所有余额取出 program_token_account.transfer(authority=signer,to=to_account,amount=u64(program_token_account.amount)) NFT 代币的交互 在Solana中铸造一个 NFT 其实就是铸造一个特殊的SPL代币，精度为 0，数量为 1，该token带有的metadata和普通SPL有些不同。\n在前面的SPL的声明中，并没有输入token的名称的信息，\nJS 交互 因为NFT和SPL相差不多，主要区别在于声明参数，和必须添加metadata部分（SPL可以不添加，这样只是会显得这个SPL没有特点，添加的话和NFT几乎一样的方法，只是属性略有区别），所以只列举了NFT的创建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 // 导入相关库 const { createMetadataAccountV3 } = require(\u0026#34;@metaplex-foundation/mpl-token-metadata\u0026#34;); const { createSignerFromKeypair, none, signerIdentity } = require(\u0026#34;@metaplex-foundation/umi\u0026#34;); const { createUmi } = require(\u0026#34;@metaplex-foundation/umi-bundle-defaults\u0026#34;); const { fromWeb3JsKeypair, fromWeb3JsPublicKey, } = require(\u0026#34;@metaplex-foundation/umi-web3js-adapters\u0026#34;); const web3 = require(\u0026#34;@solana/web3.js\u0026#34;); const { create } = require(\u0026#34;domain\u0026#34;); // 加载钱包文件 function localwalletkey(keypairFile) { const fs = require(\u0026#34;fs\u0026#34;); const loaded = web3.Keypair.fromSecretKey( new Uint8Array(JSON.parse(fs.readFileSync(keypairFile).toString())) ); return loaded; } async function creatNft() { /////////////////////// 环境准备 /////////////////////// // 加载钱包 const mywallet = localwalletkey(\u0026#34;$key_path\u0026#34;); // 创建的 spl token 的地址（spl 的精度为 0 ，数量为 1） const mint = new web3.PublicKey(\u0026#34;token addr\u0026#34;); // 创建与 solana 连接实例 const umi = createUmi(\u0026#34;https://api.devnet.solana.com\u0026#34;); // 使用现有钱包生成一个签名对象，方便签名交易 const signer = createSignerFromKeypair(umi, fromWeb3JsKeypair(mywallet)); // 设置 umi umi.use(signerIdentity(signer, true)); /////////////////////// 数据准备 /////////////////////// // 创建 NFT 的数据内容 const nftMetadata = { name: \u0026#34;NFT name\u0026#34;, symbol: \u0026#34;TN\u0026#34;, // 存储在链下，但是其他地方如 ipfs 上所得到的地址 uri: \u0026#34;json uri\u0026#34;, sellerFeeBasisPoints: 0, creators: none(), collection: none(), uses: none(), }; const accounts = { mint: fromWeb3JsPublicKey(mint), mintAuthority: signer, }; const data = { isMutable: true, colletionDetails: null, data: nftMetadata, }; /////////////////////// 上链 /////////////////////// // 将数据上链 const txid = await createMetadataAccountV3(umi, { ...accounts, ...data }).sendAndConfirm(umi); } creatNft(); ","date":"2024-08-10T17:58:02+08:00","permalink":"https://llwh2333.github.io/p/solana-%E4%B8%AD%E4%BB%A3%E5%B8%81%E7%9A%84%E4%BA%A4%E4%BA%92/","title":"Solana 中代币的交互"},{"content":"整数 1 2 3 4 5 6 7 8 9 ///////////////// 整数 ///////////////// // 不可变整数 let one_int = 33; // 可变整数 let mut sec_int = 22; sec_int = 33; // 绑定一个变量，却从未使用，rust 会弹出警告，认为这是一个 bug， // 如果想忽略，可以在变量前加上下划线，忽略这个问题 let _thir_int = 334; 类型转换 1 2 3 4 5 6 7 ///////////////// 类型转换 ///////////////// // 通过使用 as 可以实现类型间的转换 let type_int:i64 = 444; let type_sec:u32 = 11; // 通过 as 进行类型转换，实现不同类型变量的运算，才不会报错 // rust 只有进行显示 let type_thir = type_int - (type_sec as i64) ; 常量 1 2 3 4 ///////////////// 常量 ///////////////// // 不可变变量和常量相似，但常量在编译后被固定， // 所以从始至终都不可变，并用 const 声明，约定全大写、下划线链接 const MY_CONST = 221; 变量的遮蔽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ///////////////// 变量的遮蔽 ///////////////// // 变量通过重复声明名称相同的来遮蔽前一变量 // 表现上和 mut 相似，但实质上是在内存上新建一个变量， // 但名称和前一变量相同，但并未修改前一变量内存上的数据， // mut 是在原本内存上修改 fn main() { let x = 5; // 在main函数的作用域内对之前的x进行遮蔽 let x = x + 1; { // 在当前的花括号作用域内，对之前的x进行遮蔽 // 这个 x(2) 只在花括号作用域内存在 let x = x * 2; println!(\u0026#34;The value of x in the inner scope is: {}\u0026#34;, x); } println!(\u0026#34;The value of x is: {}\u0026#34;, x); } 浮点数 1 2 3 4 5 6 ///////////////// 浮点数 ///////////////// // 显式声明浮点数变量 // 这个会由编译器推导为双精度浮点数(f64)，应为默认为双精度，如果后面首先和单精度浮点运算那么会推导为单精度 let one_float = 3.0; // 这个显式的声明为单精度 let sec_float:f32 = 3.1; 布尔值 1 2 3 4 ///////////////// 布尔值 ///////////////// let t = true; // 显式类型声明 let f: bool = false; 字符 1 2 3 4 ///////////////// 字符 ///////////////// // char 类型由于 Unicode 都是 4 个字节编码，因此占用 4 个字节 // 即使部分字符在特殊编码集中不用那么多也会拓展到 4 子字节 let c = \u0026#39;z\u0026#39;; 元组 1 2 3 4 5 ///////////////// 元组 ///////////////// // 可以包含不同类型变量，长度固定 let tup: (i32, f64, u8, char) = (-500, 6.4, 1, \u0026#39;z\u0026#39;); // 解构元组 let (w, x, y, z) = tup; 数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ///////////////// 静态数组 ///////////////// // 可以包含多个变量，但类型需要一致，长度固定 let a = [1, 2, 3, 4, 5]; let first = a[0]; let second = a[1]; ///////////////// 动态数组 ///////////////// // 可以包含多个变量，长度可变，但类型一旦确定，其中包含的变量类型就会固定， fn main() { // 1.显式声明动态数组类型 let mut v1: Vec\u0026lt;i32\u0026gt; = Vec::new(); v1.push(1); v1.push(2); v1.push(3); println!(\u0026#34;vector v1: {:?}\u0026#34;, \u0026amp;v1); // 2.使用宏 vec! 来创建数组，支持在创建时就给予初始化值 let v2 = vec![1u8, 2, 3]; println!(\u0026#34;vector v2: {:?}\u0026#34;, \u0026amp;v2); } sting 类型 1 2 3 4 5 6 7 8 9 10 ///////////////// String类型 ///////////////// fn main() { let mut s = String::from(\u0026#34;Hello\u0026#34;); // 可变的 String 类型 s.push_str(\u0026#34;, world!\u0026#34;); // 修改String println!(\u0026#34;{}\u0026#34;, s); // 字符串切片是会被硬编码的，所以是不可变的 let slice = \u0026amp;s[0..5]; // 获取部分 String 作为切片 println!(\u0026#34;Slice: {}\u0026#34;, slice); } 切片类型 1 2 3 4 5 6 7 8 9 10 11 ///////////////// 切片类型 ///////////////// // 切片允许你引用集合中的一段连续元素序列，而不是整个集合。它们同样适用于数组 fn main() { let numbers = [1, 2, 3, 4, 5]; let slice = \u0026amp;numbers[1..4]; // 引用数组的一部分 // 切片让我们能够安全的访问集合的部分元素，而不用复制它们 for \u0026amp;item in slice.iter() { println!(\u0026#34;{}\u0026#34;, item); } } 结构体 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 ///////////////// 结构体 ///////////////// // 结构体就是就是自定义的一种数据结构，帮助表示一种对象 // 定义一个 Person 结构体 struct Person { name: String, age: u32, address:String, } fn main() { // 创建一个名为Alice、年龄为30的 Person 实例 let person1 = Person { name: String::from(\u0026#34;Alice\u0026#34;), age: 30, address:String::from(\u0026#34;China\u0026#34;), }; // 输出这个 Person 实例的信息 println!(\u0026#34;{} is {} years old.\u0026#34;, person1.name, person1.age); } // 同时还有一种和结构提相关联的存在，称为方法(methon)，其和函数很相似， // 主要区别在于方法存在属主，其第一个参数为：\u0026amp;self,表示属主，和 python 的类方法有点像 struct Person { name: String, age: u32, address:String, } impl Person { // 定义一个方法，展示个人信息 fn show_info(\u0026amp;self) { println!(\u0026#34;{} is {} years old.\u0026#34;, self.name, self.age); } } fn main() { let person1 = Person { name: String::from(\u0026#34;Bob\u0026#34;), age: 25, }; // 调用这个方法来展示个人信息 person1.show_info(); } 枚举 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ///////////////// 枚举类型 ///////////////// // 枚举主要是自定义一些数据变体，然后通过模式匹配进行处理 // 定义一个枚举表示不同颜色 enum Color { Red, Green, Blue, } fn main() { let color = Color::Blue; // 使用模式匹配来处理不同颜色 match color { Color::Red =\u0026gt; println!(\u0026#34;The color is Red\u0026#34;), Color::Green =\u0026gt; println!(\u0026#34;The color is Green\u0026#34;), Color::Blue =\u0026gt; println!(\u0026#34;The color is Blue\u0026#34;), } } ","date":"2024-08-09T01:41:57+08:00","permalink":"https://llwh2333.github.io/p/rust-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","title":"Rust 基础语法"},{"content":"Solana中原生代币的交互即为对Solana的代币Sol代币的代币进行交易，实际上就是对于Sol代币进行查看，转账这两个操作。\nJS 交互 以下为通过 JS 代码，查看某个特定账户的余额和从某个账户（持有该账户的私钥）向另一个账户（只需要直到公钥地址）进行转账。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 // 导入相关模块 const web3 = require(\u0026#34;@solana/web3.js\u0026#34;); // 添加一个与 Solana 的连接 // 这里采用的是库中内置的开发者网的节点地址 web3.clusterApiUrl(\u0026#39;devnet\u0026#39;) const connection = new web3.Connection(web3.clusterApiUrl(\u0026#34;devnet\u0026#34;), \u0026#34;confirmed\u0026#34;); function localwalletkey(keypairFile) { // 使用 fs(file system)模块，访问本地文件系统 const fs = require(\u0026#34;fs\u0026#34;); // 生成一个私钥钱包对象 const loaded = web3.Keypair.fromSecretKey( new Uint8Array(JSON.parse(fs.readFileSync(keypairFile).toString())) ); // 返回这个私钥钱包对象 return loaded; } // 采用异步的方法查看账户余额 async function catBalance() { // 当已知为一个公钥地址时 // mypublickey = new web3.PublicKey(\u0026#34;$public_key_addr\u0026#34;) // 当已知为自己的私钥地址(存在一个文件保存私钥)时 const pairkey = localwalletkey(\u0026#34;$key_path\u0026#34;); // 获得私钥对应的公钥地址 const mypublickey = pairkey.publicKey; const balance = await connection.getBalance(mypublickey); console.log(\u0026#34;账户余额为：\u0026#34;, balance); } // 采用异步的方法执行转账 async function transfersol() { // 转账者，发送 sol 代币 // const pairkey = localwalletkey(\u0026#34;$key_path\u0026#34;); const sender = localwalletkey(\u0026#34;wallet-keypair.json\u0026#34;); // 接收者，接收 sol 代币 const recipient = new web3.PublicKey(\u0026#34;$another_publikey\u0026#34;); // 生成一个调用系统转账程序的指令（可以看作一笔交易） let tx = web3.SystemProgram.transfer({ // 转出 sol 的公钥地址 fromPubkey: sender.publicKey, // 接收 sol 的公钥地址 toPubkey: recipient, // 转账的 sol 额度（以 lamports 为单位，这个是 sol 最小单位） lamports: web3.LAMPORTS_PER_SOL / 100, }); // 将指令放入交易（相当于指令集，可以包含多个指令）中 let transcation = new web3.Transaction().add(tx); // 对交易签名并发送，交易费用由 [sender] 支付 let signature = await web3.sendAndConfirmTransaction(connection, transcation, [sender]); console.log(\u0026#34;交易签名:\u0026#34;, signature); } async function main() { await catBalance(); await transfersol(); await catBalance(); } main(); Python 交互 通过`python`的`seahorse`框架进行转账（假设该程序需要对用户收取`sol`） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 # 导入 seahorse 的库 # 使用 seahorse 需要使用标准的命名法 from seahorse.prelude import * # 在编译后自然会产生，然后替换掉里面的字符串 declare_id (\u0026#39;11111111111111111111111111111111\u0026#39;) # 类的命名需要驼峰命名法（单词首字母大写，如：FizzBuzz） # 程序拥有的 PDA 账户，用于存储从用户那里收取到的 sol 代币 class Pda(Account): # 存储将来取出 PDA 存储的 sol 的用户地址 owner: Pubkey # 方法使用蛇形命名法（单词全部小写，使用_连接各个单词） # 每个方法都要使用 @instruction 修饰 # 初始化生成一个程序控制的 PDA 账户 @instruction def init_program_pda(owner:Signer, pad:Empty[Pda]): # 通过自定义的 seed 和程序 id 生成一个只能由该程序控制的 PDA 账户 # 该账户中的数据结构由前面的类决定 # 生成账户的费用由 payer（即 owner）出 pda = pda.init(payer=owner,seed=[\u0026#39;pda\u0026#39;]) pda.owner = owner.key() @instruction def transfer_sol(Sender:Signer,pda:Pda,amount:u64):{ # Sender 扣除指定数量的 sol （以 lamport 为单位，1 sol = 10^9 lamport）给到 pda 中 Sender.transfer_lamports(pda,amount) } @instruction def withdrawals(recipter:Signer,pda:Pda,amount:u64): # 要求指定用户才能取出 assert recipter.key() == pda.owner,\u0026#34;Caller is not the current admin\u0026#34; pda.transfer_lamports(recipter,amount) ","date":"2024-08-09T01:29:33+08:00","permalink":"https://llwh2333.github.io/p/solana-%E5%8E%9F%E7%94%9F%E4%BB%A3%E5%B8%81%E7%9A%84%E4%BA%A4%E4%BA%92/","title":"Solana 原生代币的交互"},{"content":"Uniswap V2 可以分为两个部分：core部分、periphery部分。core部分提供实际的逻辑实现，periphery部分提供和core的交互（感觉就是对其的封装）。\ncore 部分 主要有\nUniswapV2Factory：工厂合约，用于创建Pair合约 UniswapV2Pair：负责核心逻辑，如swap/mint/burn，价格预言机等功能，其本身是一个ERC20合约，继承UniswapV2ERC20(Factory 只允许创建唯一的交易对) UniswapV2ERC20：这是一个扩展的ERC20实现，用于实现LPToken。 UniswapV2Factory 主要功能是创建Pair合约，所以主要关注的也就是createPair方法：\n一句话概括逻辑：检查是否存在token对的Pair合约，然后利用creat2计算出新合约地址，赋值给对应索引，然后创建。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function createPair(address tokenA, address tokenB) external returns (address pair) { // 判断合约的 tokenA 与 tokenB 是否一致。（两个相同的币不能生成 pair 合约） require(tokenA != tokenB, \u0026#39;UniswapV2: IDENTICAL_ADDRESSES\u0026#39;); // 排序token。（防止生成 B-A 和 A-B 这样的两个实际一样的 pair 合约） (address token0, address token1) = tokenA \u0026lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA); require(token0 != address(0), \u0026#39;UniswapV2: ZERO_ADDRESS\u0026#39;); // 检查是否已经存在 require(getPair[token0][token1] == address(0), \u0026#39;UniswapV2: PAIR_EXISTS\u0026#39;); bytes memory bytecode = type(UniswapV2Pair).creationCode; bytes32 salt = keccak256(abi.encodePacked(token0, token1)); assembly { pair := create2(0, add(bytecode, 32), mload(bytecode), salt) } IUniswapV2Pair(pair).initialize(token0, token1); getPair[token0][token1] = pair; getPair[token1][token0] = pair; // populate mapping in the reverse direction allPairs.push(pair); emit PairCreated(token0, token1, pair, allPairs.length); } UniswapV2ERC20 实现了LPToken，一个标准的ERC20代币，唯一不同的是实现了 EIP-2612 以支持转账的离线授权。\n一句话概括： owner 对 spender 授权（approve）消息产生了r、s、v三个元素，根据原本属性（函数的几个输入）计算数据摘要，通过其与r、s、v还原出签名者地址，与 owner 一致（即要求签名消息为 owner 发出）执行 approve。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external { // 线下签署的交易，当前时间不能超出最后期限 require(deadline \u0026gt;= block.timestamp, \u0026#39;UniswapV2: EXPIRED\u0026#39;); // 获得摘要（包含授权方, 被授权方, 授权数量, nonce, 截止日期等信息） // 为了防止重放攻击，添加了DOMAIN_SEPARATOR等信息（包含了链id、合约等信息） bytes32 digest = keccak256( abi.encodePacked( \u0026#39;\\x19\\x01\u0026#39;, DOMAIN_SEPARATOR, keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline)) ) ); // 恢复摘要的签名地址 address recoveredAddress = ecrecover(digest, v, r, s); // 检查恢复的地址是否为 0 和是否是 owner require(recoveredAddress != address(0) \u0026amp;\u0026amp; recoveredAddress == owner, \u0026#39;UniswapV2: INVALID_SIGNATURE\u0026#39;); _approve(owner, spender, value); } UniswapV2Pair `Pair`合约主要实现了四个方法： mint：用于添加流动性，会被路由合约调用。 burn：用于移除流动性，会被路由合约调用。 swap：用于两种代币的交换，会被路由合约调用。 skim：用于清理合约中多余的 Token。无原因是多余的代币都会导致池子里的储备量和实际余额不一致，从而影响价格和流动性。 一句话概括mint部分：根据合约的两种代币的储备量计算添加流动性获得的 LP 代币：第一次添加：代币乘积的平方根 - 最小流动性 LP；非首次：添加token在存储中所占比例 * 发行 LP 代币总数。\n所以Pair合约引导用户添加流动性时，代币比例与合约存储比例一致。\n减去最小流动性 LP 时为了防止被称为((20240618154258-vpmhqnw \u0026ldquo;LP token 操纵\u0026rdquo;))的攻击\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 // mint 部分 // 添加流动性 function mint(address to) external lock returns (uint liquidity) { // 获得池里原本（指转入前）的代币数量 (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 计算当前合约中两个币的余额 uint balance0 = IERC20(token0).balanceOf(address(this)); uint balance1 = IERC20(token1).balanceOf(address(this)); // 计算投入的代币数量 uint amount0 = balance0.sub(_reserve0); uint amount1 = balance1.sub(_reserve1); // 计算协议费用 bool feeOn = _mintFee(_reserve0, _reserve1); // 获得当前 LP 代币总额 uint _totalSupply = totalSupply; // 检查是否是第一次添加流动性 if (_totalSupply == 0) { // 第一次添加流动性 // 计算池中流动性的变化 // sqrt(amount0 * amount1) - MINIMUM_LIQUIDITY liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY); // 锁定最小流动性的 LP（发送相应 LP 到地址 0 上） _mint(address(0), MINIMUM_LIQUIDITY); } else { // 非第一次添加流动性 // 根据添加代币数量占池子代币储备量比例决定 liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1); } // 要求是添加流动性，所以变化要大于0 require(liquidity \u0026gt; 0, \u0026#39;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED\u0026#39;); // 给添加流动性的用户发送相应 LP 代币 _mint(to, liquidity); // 更新储备 _update(balance0, balance1, _reserve0, _reserve1); // 检查是否开启协议费用 // 当开启时，更新 kLast 值 if (feeOn) kLast = uint(reserve0).mul(reserve1); // 触发事件 emit Mint(msg.sender, amount0, amount1); } 一句话概括burn部分：根据持有的 LP 代币在发行总数中占比，发送给持有者对应比例的两种代币。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 // burn 部分 // 除移流动性 function burn(address to) external lock returns (uint amount0, uint amount1) { // 获得原本两种代币数量 (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 获得当前代币合约地址 address _token0 = token0; // gas savings address _token1 = token1; // gas savings // 获得合约中代币余额 uint balance0 = IERC20(_token0).balanceOf(address(this)); uint balance1 = IERC20(_token1).balanceOf(address(this)); // 计算当前合约 LP 代币余额 // 计算当前合约代币余额是因为：路由合约会先把用户的流动性代币划转到该配对合约里 // 所以此处的代币余额即为需要燃烧的代币数量 uint liquidity = balanceOf[address(this)]; // 检查是否开启协议费 bool feeOn = _mintFee(_reserve0, _reserve1); // 获得 LP 代币发行总量 // gas savings, must be defined here since totalSupply can update in _mintFee uint _totalSupply = totalSupply; // 计算能提出的两种代币数量 amount0 = liquidity.mul(balance0) / _totalSupply; amount1 = liquidity.mul(balance1) / _totalSupply; // 检查取出余额大于 0 require(amount0 \u0026gt; 0 \u0026amp;\u0026amp; amount1 \u0026gt; 0, \u0026#39;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED\u0026#39;); // 移除合约中的 LP 代币（即用户想提现消耗的代币） _burn(address(this), liquidity); // 提出两种代币 _safeTransfer(_token0, to, amount0); _safeTransfer(_token1, to, amount1); // 计算提现后两种代币的余额 balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); // 更新代币的余额 _update(balance0, balance1, _reserve0, _reserve1); // 检查是否开启协议费用 // 当开启时，更新 kLast 值 // reserve0 and reserve1 are up-to-date if (feeOn) kLast = uint(reserve0).mul(reserve1); emit Burn(msg.sender, amount0, amount1, to); } 一句话概括swap部分：先向用户转去期望获得的代币， 然后根据用户传入数据选择是否执行闪电贷，最后检查当前的两种代币的余额情况，并计算是否保持 k 恒等。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 // swap 部分 // 用于两种代币的交换 function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external lock { // 检查是否有需要得到的代币 // 通常两者只有一个不为 0 ，但闪电交易时可能两个都不为 0 require(amount0Out \u0026gt; 0 || amount1Out \u0026gt; 0, \u0026#39;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT\u0026#39;); // 获得库存的代币余额 (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings // 检查合约中是否有足够的代币余额取出 require(amount0Out \u0026lt; _reserve0 \u0026amp;\u0026amp; amount1Out \u0026lt; _reserve1, \u0026#39;UniswapV2: INSUFFICIENT_LIQUIDITY\u0026#39;); uint balance0; uint balance1; { // 使用块作用范围，防止堆栈过深 address _token0 = token0; address _token1 = token1; // 检查接收者地址 require(to != _token0 \u0026amp;\u0026amp; to != _token1, \u0026#39;UniswapV2: INVALID_TO\u0026#39;); // 将代币转发给指定用户 if (amount0Out \u0026gt; 0) _safeTransfer(_token0, to, amount0Out); if (amount1Out \u0026gt; 0) _safeTransfer(_token1, to, amount1Out); // data 参数大于 0 ，表示这是一个闪电贷 // 将 to 地址转为 IUniswapV2Callee 并调用其 uniswapV2Call() 函数，这其实就是一个回调函数，to 地址需要实现该接口。 if (data.length \u0026gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data); // 获取合约的两个代币的当前余额 balance0 = IERC20(_token0).balanceOf(address(this)); balance1 = IERC20(_token1).balanceOf(address(this)); } // 计算两个代币的实际转入量 // 即进行交换时，代币的实际转入量是多少 // 因为计算转入，所以余额变大才计算，变小则为0 uint amount0In = balance0 \u0026gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0; uint amount1In = balance1 \u0026gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0; // 要求至少有一个转入（转换至少一进一出） require(amount0In \u0026gt; 0 || amount1In \u0026gt; 0, \u0026#39;UniswapV2: INSUFFICIENT_INPUT_AMOUNT\u0026#39;); { // 保证 k 恒等式约束 uint balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3)); uint balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3)); require(balance0Adjusted.mul(balance1Adjusted) \u0026gt;= uint(_reserve0).mul(_reserve1).mul(1000**2), \u0026#39;UniswapV2: K\u0026#39;); } _update(balance0, balance1, _reserve0, _reserve1); emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to); } periphery 部分 periphery模块提供了和 UniswapV2进行交互的外围合约，包含了以下主要合约：\nUniswapV2Router02：最新版的路由合约，相比UniswapV2Router01增加了对FeeOnTransfer代币的支持；实现Uniswap v2最常用的接口，比如添加/移除流动性，使用代币 A 交换代币 B，使用ETH交换代币等，用来提升用户的体验。 UniswapV1Router01：旧版本Router实现，与Router02类似，但不支持FeeOnTransferTokens，目前已不使用 UniswapV2Migrator：用于迁移流动性（从v1迁移到v2合约） UniswapV2Router02 是与用户进行交互的入口，主要提供了添加流动性、移除流动性和兑换的系列接口，并提供了几个查询接口\n一句话概括添加流动性：计算最终需要两种代币数量，然后将两种代币转入合约对中，调用合约对的mint函数铸造对应的 LP 给添加者。\n计算过程：获取代币对合约中库存量：如果为空表示新合约，那么最终数量等于期望数量；反之计算出结果(amountAMin = mountA \u0026amp;\u0026amp; amountBMin \u0026lt;= mountB \u0026lt;= amountBDesired) || (amountAMin \u0026lt;= mountA \u0026lt;= amountADesired \u0026amp;\u0026amp; mountB = amountBDesired)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 // 添加流动性的接口：addLiquidity、addLiquidityETH（这个主要是定义另一个代币为 ETH） // 本质上就是支付两种代币，换回对应这两种代币的流动性代币 LP-Token。 // addLiquidity function addLiquidity( // 配对的代币 address tokenA,address tokenB, // 预期支付代币的数量 uint amountADesired,uint amountBDesired, // 根据预期值和滑点计算的最小数量 uint amountAMin,uint amountBMin, address to, uint deadline // ensure 确定是否过期 ) external virtual override ensure(deadline) returns (uint amountA, uint amountB, uint liquidity) { // 调用 _addLiquidity 获得最终需要支付的代币数量 (amountA, amountB)= _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin); // 计算出两个代币对的合约地址 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // 从 msg.sender 账户中发送 amount 数量的 token 到 pair 合约中 // 因为使用了 transferfrom 函数，所以用户调用前需要授权给路由合约 TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA); TransferHelper,safeTransferFrom(tokenB, msg.sender, pair, amountB); // 铸造相应数量的 LP 代币给用户，返回得到流动性的改变 liquidity = IUniswapV2Pair(pair).mint(to); } function _addLiquidity( address tokenA,address tokenB, uint amountADesired,uint amountBDesired, uint amountAMin,uint amountBMin ) internal virtual returns (uint amountA, uint amountB) { // 检查代币对合约是否存在，不存在就创建 if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) { IUniswapV2Factory(factory).createPair(tokenA, tokenB); } // 获得两个token在池子中的储备量 (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB); // 当储备量均为 0 时，这时应该是新建的代币对合约 if (reserveA == 0 \u0026amp;\u0026amp; reserveB == 0) { // 新建合约则实际支付的数量就和预期数量一致 (amountA, amountB) = (amountADesired, amountBDesired); } else { // 根据两种代币储备量，其中一个代币的预期数量，计算另一个代币的等值的数值 // 应该是相当于计算兑换比例 uint amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB); // 检查结果是否小于预期值 if (amountBOptimal \u0026lt;= amountBDesired) { // 检查是否低于最小值（超过滑点的容忍界限） require(amountBOptimal \u0026gt;= amountBMin, \u0026#39;UniswapV2Router: INSUFFICIENT_B_AMOUNT\u0026#39;); // 通过就直接返回 (amountA, amountB) = (amountADesired, amountBOptimal); } else { // 结果能换回更多的零一币，则需要倒转过来检查是否超过滑点。 uint amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA); assert(amountAOptimal \u0026lt;= amountADesired); require(amountAOptimal \u0026gt;= amountAMin, \u0026#39;UniswapV2Router: INSUFFICIENT_A_AMOUNT\u0026#39;); (amountA, amountB) = (amountAOptimal, amountBDesired); } } } 一句话概括除移流动性：获取对应代币合约对，然后发送 LP 代币到合约对中，然后调用代币对合约的销毁函数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 移除流动性接口： // removeLiquidity：和 addLiquidity 相对应，会换回两种 ERC20 代币 // removeLiquidityETH：和 addLiquidityETH 相对应，换回的其中一种是主币 ETH // removeLiquidityWithPermit：也是换回两种 ERC20 代币，但用户会提供签名数据使用 permit 方式完成授权操作 // removeLiquidityETHWithPermit：也是使用 permit 完成授权操作，换回的其中一种是主币 ETH // removeLiquidityETHSupportingFeeOnTransferTokens：名字真长，功能和 removeLiquidityETH 一样，不同的地方在于支持转账时支付费用 // removeLiquidityETHWithPermitSupportingFeeOnTransferTokens：功能和上一个函数一样，但支持使用链下签名的方式进行授权 // removeLiquidity // 其他几种合约基本都是基于 removeLiquidity 衍生出来 function removeLiquidity( address tokenA,address tokenB, uint liquidity, uint amountAMin,uint amountBMin, address to, uint deadline ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) { // 获取代币对合约地址 address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB); // 先将 LP 代币发往合约 IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // 燃烧 LP 代币，同时发送两种代币到目标地址 to ，返回发送的数量 (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to); // 对代币对做排序 (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB); // 得到正确的发送数量排序 (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0); // 收益是否达到预期（计算滑点） require(amountA \u0026gt;= amountAMin, \u0026#39;UniswapV2Router: INSUFFICIENT_A_AMOUNT\u0026#39;); require(amountB \u0026gt;= amountBMin, \u0026#39;UniswapV2Router: INSUFFICIENT_B_AMOUNT\u0026#39;); } ","date":"2024-08-08T19:44:44+08:00","permalink":"https://llwh2333.github.io/p/uniswap-v2-%E4%B8%BB%E8%A6%81%E5%90%88%E7%BA%A6/","title":"Uniswap V2 主要合约"},{"content":"V2 的预言机主要是通过计算时间加权平均价（TWAP, Time Weighted Average Price）来得到价格的。\n称为时间加权是因为，计算价格时考虑了时间因素，价格的每次更新包含了上次价格时间累积值，本次价格时间累积值，中间间隔时间三个元素。\n时间累积值 在 V2 中，合约会记录价格时间累积值，这个价格时间累计值相当于价格*时间得到的值，这个便是 Uniswap V2 的 TWAP 的基础。这个价格时间累积值计算公式为：\n$$ a_i = a_{i-1} + \\Delta t * {p_{i-1}} $$\n其中 $a_i$ 指第 i 个价格时间累积值，$a_0$ 为 0 ，$\\Delta t$ 指两个值之间经过的时间，$p_{i-1}$ 指$a_{i-1}$所在区块最后一笔交易的价格。\n固定时间窗口 TWAP 即选择一个固定的时间$\\Delta T$值，计算时间间隔为$\\Delta T$的两个$a_i 和 a_j$，然后得到这段时间的平均价格，然后每隔$\\Delta T$时间计算一次价格。\n滑动时间窗口 TWAP 上述的固定时间窗口 TWAP 每隔一段固定时间才会更新一次价格，这种价格除非固定时间很短，不然价格变化很容易不平滑，固定时间越长越陡峭，所以实际更多的采用滑动事件窗口 TWAP。\n滑动时间窗口可以分为两个部分：时间窗口、滑动。\n时间窗口，和上面一样指选择一个$\\Delta T$值来计算时间段内的平均价格。\n滑动，指不再是间隔$\\Delta T$时间计算一次，而是另外设置间隔$\\Delta n$时间计算一次，即每间隔$\\Delta n$时间滑动一次时间窗口。\n","date":"2024-08-08T19:39:32+08:00","permalink":"https://llwh2333.github.io/p/uniswap-v2-%E9%A2%84%E8%A8%80%E6%9C%BA/","title":"Uniswap V2 预言机"},{"content":"总的来说 Solana 的账户类型可以分为三种类型：\n程序账户\n程序账户就是可以运行代码的账户，其中并不存储数据，可以看作 windows 上的 exe 文件，相当于一个只读的存在，仅负责执行逻辑。最明显的特征就是executable值为true。 数据账户\n数据账户就是存储数据的账户，但其并不能运行代码，可以通过可执行账户修改其中的数据。最明显的特征就是executable值为false。 原生账户\nSolana 中包含少量的原生程序，既属于validator实现的一部分，也为网络提供各种核心功能。 Solana在账户的属性中存在一些固定的属性：data（存放数据或代码）、executable、lamports（SOL 余额）、owner（账户的所有者）\n此外，还有其它类型的账户，但都可以归类为上述的账户类型：\n钱包账户\n主要就是用户使用的账户，对于每一个拥有公私钥的账户，都可以认为是一个钱包账户（感觉本质上是一个数据账户，但不存储任何数据），用户通过私钥对消息进行签名，表示这个账户（公钥地址）的所有权，来进行操作。 系统账户\n是由 Solana 系统程序管理的账户，用于执行网络的基础操作（创建账户、转账等操作）。由于每个新账户都是由系统账户创建的（系统账户执行基础操作），所以 Owner 都是系统账户 用户通过钱包账户向系统程序发送交易请求，就可以创建新的系统账户 代币账户\nSolana中除了SOL这个原生代笔是所有账户都可以直接持有，如果用户想持有一个SPL代笔（用户发行的其他代币），就需要一个代币账户，每一种代币都需要一个代币账户（代币账户中存在mint表示这个代币账户保存的是哪个代币的数量）（所以这个应该也算得上是数据账户、PDA账户）\n程序衍生地址（PDA）\n在Solana中，由于程序账户本身不存储任何数据，只执行逻辑，所以对于需要加载的数据，就存放在PDA中，PDA可以被程序账户通过seed（由程序账户设置）和程序账户的programeid寻找到对应的PDA地址，然后提取涉及的数据。 参考文章 Solana 秘籍\n","date":"2024-08-08T17:57:49+08:00","permalink":"https://llwh2333.github.io/p/solana-%E4%B8%AD%E7%9A%84%E8%B4%A6%E6%88%B7%E7%B1%BB%E5%9E%8B/","title":"Solana 中的账户类型"},{"content":"官方的 Paymaster.sol 部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // SPDX-License-Identifier: MIT pragma solidity 0.8.20; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;./interfaces/IPaymaster.sol\u0026#34;; import \u0026#34;./interfaces/IPaymasterFlow.sol\u0026#34;; import \u0026#34;./L2ContractHelper.sol\u0026#34;; // 这是个假出纳员。它希望 paymasterInput 包含其“签名”以及所需的汇率 // 仅支持基于授权的 paymaster 流程 contract TestnetPaymaster is IPaymaster { function validateAndPayForPaymasterTransaction( bytes32, bytes32, Transaction calldata _transaction ) external payable returns (bytes4 magic, bytes memory context) { // 默认交易已经被接收（应该是指通过交易验证，指差提供足够的交易费用即可执行） // 应该是函数的函数选择器 magic = PAYMASTER_VALIDATION_SUCCESS_MAGIC; // 只能由系统合约 bootloader 调用 require( msg.sender == BOOTLOADER_ADDRESS, \u0026#34;Only bootloader can call this contract\u0026#34; ); // 输入大于 4 ，因为至少要有函数选择器 require( _transaction.paymasterInput.length \u0026gt;= 4, \u0026#34;The standard paymaster input must be at least 4 bytes long\u0026#34; ); // 获得函数选择器 bytes4 paymasterInputSelector = bytes4( _transaction.paymasterInput[0:4] ); // 检查函数选择器是否对应 approvalBased 函数的函数选择器 if (paymasterInputSelector == IPaymasterFlow.approvalBased.selector) { // While the actual data consists of address, uint256 and bytes data, // the data is not needed for the testnet paymaster // 数据由地址、uint256、字节数据组成，但 testnet 上的 paymaster 并不需要 (address token, uint256 amount, ) = abi.decode( _transaction.paymasterInput[4:], (address, uint256, bytes) ); // 首先检查用户（交易的发起方）是否提供了足够的限额 address userAddress = address(uint160(_transaction.from)); address thisAddress = address(this); uint256 providedAllowance = IERC20(token).allowance( userAddress, thisAddress ); require( providedAllowance \u0026gt;= amount, \u0026#34;The user did not provide enough allowance\u0026#34; ); // 测试网上的 paymaster 用 X wei 的 ETH 交换 X wei 的 token（1：1交换） uint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas; if (amount \u0026lt; requiredETH) { // 虽然条款中明确规定，用户少付了费用给 paymaster 交易将不会被接收（因为这可能会导致交易得不到足够的gas）， // 但我们并不希望交易会 revert，因为对于费用的估计，我们允许用户提供更少数量的资金来维持财产， // 如果使用 X gas 能使交易成功，那么 X+1 gas 同样可以 magic = bytes4(0); } // 从用户处拉取所有的 tokens try IERC20(token).transferFrom(userAddress, thisAddress, amount) {} catch (bytes memory revertReason) { // 如果 revert 原因为空或仅由函数选择器表示，我们将用更用户友好的消息替换错误 //（应该就是让错误更加具有可读性） if (revertReason.length \u0026lt;= 4) { revert(\u0026#34;Failed to transferFrom from users\u0026#39; account\u0026#34;); } else { assembly { revert(add(0x20, revertReason), mload(revertReason)) } } } // bootloader 从不返回任何数据，所以可以安全的忽略 //（这里应该是项 bootloader 转账，提供足够的交易费用） (bool success, ) = payable(BOOTLOADER_ADDRESS).call{ value: requiredETH }(\u0026#34;\u0026#34;); require(success, \u0026#34;Failed to transfer funds to the bootloader\u0026#34;); } else { revert(\u0026#34;Unsupported paymaster flow\u0026#34;); } } function postTransaction( bytes calldata _context, Transaction calldata _transaction, bytes32, bytes32, ExecutionResult _txResult, uint256 _maxRefundedGas ) external payable override { // Nothing to do } receive() external payable {} } 官方的交互示范脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 import { ethers } from \u0026#34;ethers\u0026#34;; import { Provider, Contract, utils, Signer } from \u0026#34;zksync-ethers\u0026#34;; // 希望执行合约的地址，过去部署的 ZeekMessages 合约的地址 const ZEEK_MESSAGES_CONTRACT_ADDRESS = \u0026#34;\u0026#34;; // ERC20 代币的合约地址 const TOKEN_CONTRACT_ADDRESS = \u0026#34;\u0026#34;; // Message to be sent to the contract const NEW_MESSAGE = \u0026#34;This tx cost me no ETH!\u0026#34;; (async () =\u0026gt; { try { // Note that the script needs the ABI which is generated from the compilation artifact. // Make sure contract is compiled and artifacts are generated const messagesContractArtifactsPath = `browser/artifacts/contracts/zksync_first.sol/ZeekMessages.json`; const tokenContractArtifactsPath = `browser/artifacts/contracts/zksync_erc20.sol/TestToken.json`; const messagesContractABI = JSON.parse( await remix.call(\u0026#34;fileManager\u0026#34;, \u0026#34;getFile\u0026#34;, messagesContractArtifactsPath) ); const tokenContractABI = JSON.parse( await remix.call(\u0026#34;fileManager\u0026#34;, \u0026#34;getFile\u0026#34;, tokenContractArtifactsPath) ); console.log(\u0026#34;Sending a transaction via the testnet paymaster\u0026#34;); const browserProvider = new ethers.providers.Web3Provider(web3Provider); const zkProvider = new Provider(\u0026#34;https://sepolia.era.zksync.dev\u0026#34;); // const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner(0) const zkSigner = Signer.from(browserProvider.getSigner(), zkProvider); // const walletAddress = await signer.getAddress(); const walletAddress = await zkSigner.getAddress(); console.log(walletAddress); // initialise messages and token contracts with address, abi and signer // 初始化合约，通过合约地址、abi、签名者 const messagesContract = new Contract( ZEEK_MESSAGES_CONTRACT_ADDRESS, messagesContractABI.abi, zkSigner ); const tokenContract = new Contract(TOKEN_CONTRACT_ADDRESS, tokenContractABI.abi, zkSigner); // 检索并打印当前钱包余额 let ethBalance = await zkProvider.getBalance(walletAddress); console.log(`Account ${walletAddress} has ${ethers.utils.formatEther(ethBalance)} ETH`); let tokenBalance = await tokenContract.balanceOf(walletAddress); console.log( `Account ${walletAddress} has ${ethers.utils.formatUnits(tokenBalance, 18)} tokens` ); //检索测试网上的 paymaster 地址（应该是官方的示例合约地址） const testnetPaymasterAddress = await zkProvider.getTestnetPaymasterAddress(); console.log(`Testnet paymaster address is ${testnetPaymasterAddress}`); // 获取当前 gas 费用 const gasPrice = await zkProvider.getGasPrice(); console.log(\u0026#34;gasPrice \u0026gt;\u0026gt; \u0026#34;, gasPrice); // 明确 paymaster 的 gas 估计范围 //（应该是测试 1 个 ERC20 token 可代付的 gas 数量） const paramsForFeeEstimation = utils.getPaymasterParams(testnetPaymasterAddress, { type: \u0026#34;ApprovalBased\u0026#34;, token: TOKEN_CONTRACT_ADDRESS, // 设置 minimalAllowance 为 1 来估计 // 授权支出的 erc20 代币数量 minimalAllowance: ethers.BigNumber.from(1), // 空字节，因为测试网 paymaster 不使用 innerInput innerInput: new Uint8Array(0), }); // 通过 paymaster 估计 gasLimit //（估计执行目标函数所需要花费的 gas Limit） const gasLimit = await messagesContract.estimateGas.sendMessage(NEW_MESSAGE, { customData: { gasPerPubdata: utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, paymasterParams: paramsForFeeEstimation, }, }); console.log(\u0026#34;gasLimit \u0026gt;\u0026gt; \u0026#34;, gasLimit); // 使用 ETH 计算的费用将与使用测试网 paymaster 的 ERC20 代币相同 //（计算出所需要的 ETH 费用） const fee = gasPrice * gasLimit; console.log(\u0026#34;Fee \u0026gt;\u0026gt;\u0026#34;, fee); // 新的 paymaster 的参数作为费用的 minimalAllowance（在合约中我们可以看到 token 和 ETH 是 1：1兑换的 ） const paymasterParams = utils.getPaymasterParams(testnetPaymasterAddress, { type: \u0026#34;ApprovalBased\u0026#34;, token: TOKEN_CONTRACT_ADDRESS, // provide estimated fee as allowance minimalAllowance: fee, // empty bytes as testnet paymaster does not use innerInput innerInput: new Uint8Array(0), }); // 完全覆盖对象，包含了 maxFeePerGas 和 maxPriorityFeePerGas //（应该就是使用 paymaster 需要额外添加的交易参数） const txOverrides = { maxFeePerGas: gasPrice, // 为优先打包愿意多付的 gas 费用 maxPriorityFeePerGas: \u0026#34;1\u0026#34;, gasLimit, customData: { gasPerPubdata: utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, paymasterParams, }, }; console.log(\u0026#34;overrides \u0026gt;\u0026gt; \u0026#34;, txOverrides); console.log(`Sign the transaction in your wallet`); // 发送附有 paymaster 参数进行重载的交易 const txHandle = await messagesContract.sendMessage(NEW_MESSAGE, txOverrides); console.log( `Transaction ${txHandle.hash} with fee ${ethers.utils.formatUnits( fee, 18 )} ERC20 tokens, sent via paymaster ${testnetPaymasterAddress}` ); await txHandle.wait(); console.log(`Transaction processed`); ethBalance = await zkProvider.getBalance(walletAddress); tokenBalance = await tokenContract.balanceOf(walletAddress); console.log(`Account ${walletAddress} now has ${ethers.utils.formatEther(ethBalance)} ETH`); console.log( `Account ${walletAddress} now has ${ethers.utils.formatUnits(tokenBalance, 18)} tokens` ); console.log(`Done!`); } catch (e) { console.error(\u0026#34;Error in script!\u0026#34;); console.error(e.message); console.error(e); } })(); ","date":"2024-08-08T17:56:25+08:00","permalink":"https://llwh2333.github.io/p/%E5%AF%B9-zksync-%E5%AE%98%E6%96%B9-paymaster-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3/","title":"对 zksync 官方 Paymaster 示例代码的理解"},{"content":"zksync Era 中的抽象账户与 EIP-4337 的抽象账户 ZKsync 和以太坊 EIP 4337 的原生账户抽象旨在增强账户的灵活性和用户体验，但它们在以下关键方面有所不同：\n实现层级 ZKsync 的账户抽象在协议层级（我的理解是从底层）进行集成；但EIP-4337 避开了协议级别的实现（众所周知，EIP-4337期望在应用层实现）。 账户类型 在 ZKsync Era 中，智能合约账户和paymasters都是第一类型账户。在底层中，所有的账户（包括 EOA）的行为也和智能合约账户类似（都是合约函数的执行），同时所有的账户都支持使用paymasters 交易处理 EIP-4337为智能合约账户引入了单独的交易流程：通过依赖于单独的内存池以及Bundlers节点（能够打包用户操作，并将其发送给EntryPoint合约 ）进行用户的操作，这使得出现了两个独立交易流程（一个是正常以太坊上的交易流程，一个是依靠Bundlers等建立的交易流程） ZKsync Era 上存在一个统一的内存池给账户（包括 EOA 和智能合约账户）交易使用。ZKsync Era 中 Operator （定序器）承当了Bundlers的角色，对于用户（EOA 和合约账户一样）发起的交易将被发送到Bootloader（类似于EntryPoint合约的角色），从而产生一个mempool与交易流。 Paymasters 支持： ZKsync Era 通过单一的交易流程（不再像EIP-4337中分为两个部分），允许 EOA 和智能合约账户从paymasters中受益 EIP-4337中对 EOA 而言并不支持paymasters，因为paymasters仅在与智能合约交互中实现。 介绍 以太坊中有两种类型的账户：\n外部拥有账户（EOA，即用户使用私钥直接控制进行交易的账户） 合约账户（拥有代码的账户，不存在私钥，所以用户不能直接控制进行交易） 在 ZKsync Era 中实现这样的账户：可以直接发起一笔交易（如 EOA 一般），也能在其中实现一些逻辑（即放入智能合约代码），这种账户称为抽象账户（AA 账户）。 由于用户的账户可以是 AA 账户，所以可以对自己的账户进行编程，然后用户自己调用自己账户上的函数进行交易，因此，用户可以自定义签名算法、多签、支出限制等。同时，用户可以通过paymasters来帮助交易，即交易的gas由paymasters付出（前提是用户在paymasters有存款或授权一定数量的 ERC20 代币）。这使得用户在区块链上能有更好的体验了。 设计 ZKsync 上的帐户抽象协议与 EIP-4337非常相似，但为了效率和更好的用户体验，仍然有所不同。\nNonce 的唯一性 当前的模型不允许自定义钱包同时发送多笔交易并保持确定的顺序 对于 EOA，Nonce 的计数会依次增长（每笔交易都会递增）；对于自定义账户，无法保证交易顺序 未来计划切换到可以在顺序或任意 Nonce 之间选择的模型 每个区块中，对于每个交易都有一个重要的不变量，唯一的交易哈希值。虽然账户可以接收多个完全相同的交易，但对于抽象账户而言并不容易。尽管这些交易在技术上是合规的，但索引器和其他工具很难处理违反了哈希唯一的情况。\n需要有一种的协议级别的方法，来保证交易哈希不重复的方法，最简单又便宜的方法就是让让交易对（发送者、Nonce）始终唯一。\n就采用了以下协议：\n每个交易开始前，系统会通过NonceHolder（会为每个账户记录使用过的 Nonce）检查 Nonce 是否已被使用 如果 Nonce 尚未使用，则开始对交易的验证（验证交易是否满足执行条件），在验证期间，提供的随机数被标记为used。 验证完成后，系统检查 Nonce 是否标记为已使用。 用户可以使用一个任意的 256 bit 的数字作为 Nonce，并且可以在系统合约中对应的 key 下放置任意的非零值。但仅有协议层面支持，但在 server 端并不支持这么做，目前仅支持通过顺序使用 Nonce 值（使用incrementMinNonceIfEquals方法，重新标记能使用的最低 Nonce）。\n标准化交易哈希 在未来，计划在 ZKsync 上支持高效的交易包含证明。这需要我们在Bootloader中计算交易哈希。因为这种计算需要消耗gas，所以将计算交易哈希交给 AA 方法的接口才公平（防止账户可能由于某些原因需要该值），这也是为何下面描述的IAccount与IPaymaster接口的所有的方法都包含交易哈希以及推荐的签名摘要（由 EOA 对本次交易进行签名的摘要）。\nInterface IAccount interface 这个就是建议每个账户都需要实现的 IAccount interface。它包含五个接口：\n个人认为下面的”系统“通常指Bootloader，但又有时候表示更大的概念，即整个 zksync 系统\nvalidateTransaction：是必须实现的，系统需要它来确定 AA 逻辑是否同意继续进行交易。当交易不合规（如签名错误），该方法将会revert；如果调用成功，则认为已实现的账户逻辑已同意交易，系统将继续进行交易。 executeTransaction：是必须实现的，当用户支付费用（应该就是gas费）后，系统将会调用。该函数会执行交易的实施。 payForTransaction：是可选实现的，当交易没有paymaster时，系统将会调用它。这个方法是由当前账户支付交易费用，如果当前账户永远不会支付任何费用，并且始终都会依赖paymaster进行费用支付，那么可以不实现。这个方法将会发送至少tx.gasprice * tx.gasLimit的 ETH 给Bootloader（如果被调用的话）。 prepareForPaymaster：是可选实现的，如果交易有paymaster代为支付交易费用，那么系统将会调用它。这个方法用来准备和paymaster进行交互（最著名的示例就是使用 ERC20 让paymaster代为支付交易费用）。 executeTransactionFromOutside：是可选实现的，但强烈推荐实现，因为在 priority 模式下的某些情况时（如 operator 没有响应），需要从你那来自”外部“的账户开始交易（即从 EOA 开始一个智能合约的交易，如以太坊上一样）。 IPaymaster interface 与EIP-4337相同，ZKsync 同样支持paymaster：用于代付其他账户交易执行费用的账户。每个paymaster都需要实现 IPaymaster interface，其包含以下两个方法：\nvalidateAndPayForPaymasterTransaction：是必须实现的，系统需要使用它来确认paymaster是否同意代付这笔交易。如果同意，则这个方法至少发送tx.gasprice * tx.gasLimit的 ETH 给 operator 。它需要返回context来作为postTransaction方法的调用参数之一。\npostTransaction：是可选实现的，在交易执行后被调用。与EIP-4337不同，并不能保证会调用此方法，尤其是交易因为out of gas错误而失败。其需要四个参数：\n还有一个变量_suggestedSignedHash不知道为啥官方文档里不讲，表示交易哈希，由 EOA 进行签名\n_context：validateAndPayForPaymasterTransaction的返回 _txHash：交易本身 _txResult：指示交易是否执行成功 _maxRefundedGas：可以退还给paymaster的gas的最大数量上限 Transaction 结构体的保留字段 对于上面的每个方法都会接收 Transaction 结构，虽然大多数字段不言自明，但仍旧有 6 个reserved字段（在下面结构中貌似被单独命名了出来，并没有如文档所讲放在reserved中），不命名的原因在于：未来的某些交易类型中可能不需要他们。目前为：\nreserved[0]：是 Nonce reserved[1]：是随交易传递的msg.value 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 struct Transaction { // The type of the transaction. uint256 txType; uint256 from; uint256 to; uint256 gasLimit; uint256 gasPerPubdataByteLimit; uint256 maxFeePerGas; uint256 maxPriorityFeePerGas; uint256 paymaster; uint256 nonce; uint256 value; uint256[4] reserved; bytes data; bytes signature; bytes32[] factoryDeps; bytes paymasterInput; bytes reservedDynamic; } 交易流程 每笔交易都会有如下流程处理\n验证 验证过程就是：系统确定交易是否能够执行。如果这笔交易在任何验证点失败，则不会向用户收取任何费用，并且交易不会包含在区块中（应该是指这笔交易不会有任何的记录，即相当于没有这笔交易）。\n验证过程的步骤：\nNonce 验证：验证交易的 Nonce 是否被使用过\n交易验证：调用账户上的validateTransaction方法，检查交易是否合规。方法执行成功且没有 revert 则进行下一步\n标记 Nonce：验证通过后，标记交易的 Nonce 已经使用\n费用处理：这个部分分为两种（根据是否使用paymaster，但结果应该都是向Bootloader支付费用）：\nStandard Transactions：在账户上使用payForTransaction方法（账户自己付款），当此方法没有 revert ，则继续 Paymaster Transactions：首先交易发送者调用prepareForPaymaster，成功执行后调用（应该是由系统调用）paymaster的validateAndPayForPaymasterTransaction函数。如果两个函数都没有 revert，则继续 资金验证：系统确定Bootloader至少收到tx.gasPrice * tx.gasLimit的 ETH。如果所需的资金已经保存了，则交易被视为已经验证，准备进行下一步\n执行 执行步骤负责执行实际的交易操作，并将任何为使用的gas退还给用户，即使此步骤中出现 revert 情况，交易人就包含在区块中。\n执行过程步骤：\n交易执行：调用账户上的executeTransaction方法，执行交易 paymaster的交易后处理（仅在涉及paymaster时适用）：调用paymaster的postTransaction方法。这个方法通常将未使用的gas退还给发送者（应该就是当前账户了），尤其是paymaster采用的是 ERC20 代币作为代付费用（即向当前账户收取 ERC20 ，然后代付gas）。 费用 不同协议之间处理对于交易费的处理不同，如 EIP-4337 和 ZKsync 之间。\nEIP-4337 的 Gas Limit EIP-4337定义了三种Gas Limit来管理不同交易阶段的成本（应该是指将不同阶段的gas费用分开统计）：\nverificationGas：包含交易验证所需的gas executionGas：交易执行所需的gas preVerificationGas：在主要验证前所需的gas（这个不太能理解，但看下面的描述，是转账 ERC20 的费用？） ZKsync Era 中统一的 Gas Limit 在 ZKsync Era 中，使用单个Gas Limit字段处理所有与交易相关的成本，所以这个统一的Gas Limit需要包含：\n交易验证 代支付逻辑费用（包括任意 ERC20 转账的费用） 交易本身的执行 估算 Gas 默认情况下，estimateGas函数计算需要的gas量，并包含一个常数。这个常数用于 EOA 交易的支付费用和签名验证（没看懂这句话）。\n使用 SystemContractsCaller 库 为了安全起见，NonceHolder（管理账户 Nonce）和ContractDeployer（负责部署合约）的系统合约都只能在拥有isSystem的特殊标志时调用。想要拥有此特殊标志来进行调用，需要使用 SystemContractsCaller 库中的systemCall或systemCallWithPropagatedRevert或systemCallWithReturndata（后面两种内部都是调用了systemCall）方法。\n当开发自定义的账户时，基本上都必定使用这个库，因为这是调用NonceHolder系统合约的非视图的唯一方法。此外，如果想允许用户自己部署自己的合约，则必须使用这个库。可以使用 EOA 账户的实现（默认账户实现，所有没有包含代码的账户默认继承的）作为参考。\n扩展 EIP-4337 主要是 EIP-4337对 ZKsync 原生帐户抽象的扩展概述。\n为了向 operator 提供 Dos 保护，EIP-4337对账户的验证步骤施加了多项限制（如不允许访问能够变化的信息，如当前块时间、数字、哈希）。其中大多数，尤其是那些和禁止操作码相关的内容，仍然具有意义，但为了用户有更好的体验，其中的一些限制已经取消\n拓展允许的操作码 允许使用已部署的call/delegateCall/staticcall合约。和以太坊不同，我们无法编辑已部署的代码或通过自毁删除合约，所以我们可以确保合约执行期间的代码是相同的。\n扩展属于用户的 slots 集 这一部分就没看懂\n在原本的EIP中，AA 的validateTransaction步骤（检查交易是否合规）只允许读取自己存储的 slots 。但有些 slots 在语义上属于该用户，但实际上位于另一个合约的地址上，例如 ERC20 的余额。\n此限制通过确保各个账户用于验证的 slots 不重叠来提供 DDos 安全性，因此他们不需要实际上属于账户的存储空间中。\n为了能够在验证步骤中读取用户的 ERC20 余额或授权额度，在验证步骤中地址为 A 的账户将允许使用以下类型的 slots：\n属于地址 A 的 slots 任何其他地址上的 slots A（这个不懂） 然和其他地址上的keccak256(A || X)类型的 slots（包阔mapping(address =\u0026gt; value)，通常用于 ERC20 代币中的余额） 未来会允许什么？ 未来可能允许有时限的交易，例如允许检查block.timestamp \u0026lt;= value是否返回false等等。这将需要部署此类可信方法的库，但它将大大增强账户的功能。\n建立智能账户 想在 zksync 上构建自定义账户（应该就是合约账户，带有合约的抽象账户），开发人员必须实现特定的接口，并遵循推荐的账户部署和管理的最佳实践。\n接口实现 每个自定义账户都应该实现 IAccount interface（这个可以在 DefaultAccount.sol 中找到示例）。\n当外部地址调用时，此实现会返回空值，这可能不是您的自定义帐户所希望的行为。\nEIP-1271 集成 对于智能钱包，强烈鼓励实施EIP-1271签名验证方案（让合约能够和 EOA 账户一样能够对消息进行签名，同时可以验证签名）。该标准得到了 ZKsync 团队的认可，并且是签名验证库的组成部分。\n部署流程 部署账户的逻辑与部署标准智能合约的过程类似，但为了区分不打算被视为账户的智能合约，需要使用ContractDeployer系统合约的createAccount/create2Account方法，而不是使用create/create2（从代码中看没啥区别，因为create中调用了createAccount）。\n使用 zksync-ethers SDK 的示例 (v5) 1 2 3 4 5 import { ContractFactory } from \u0026#34;zksync-ethers\u0026#34;; const contractFactory = new ContractFactory(abi, bytecode, initiator, \u0026#34;createAccount\u0026#34;); const aa = await contractFactory.deploy(...args); await aa.deployed(); 验证步骤限制 目前自定义账户验证规则尚未完全强制执行，将来可能变化：\n账户只能与属于他们自己的 slots 进行交互\n账户逻辑中禁止使用上下文变量（如block.number）\n账户必须将 Nonce 加一，以保持哈希冲突的抵抗力\n这些限制尚未在 电路/VM 级别强制执行，并且不适用于 L1-\u0026gt;L2 事务。\nNonce 管理 交易和部署的 Nonce 都被整合到NonceHolder中进行优化。使用incrementMinNonceIfEquals函数安全的增加账户的 Nonce。\n发送交易 目前仅支持EIP-712（对结构化数据进行哈希和签名的标准）格式的交易从自定义账户发送。交易必须指定from字段作为账户地址，并在customData中包含customSignature。\n交易提交示例 1 2 3 4 5 6 7 8 9 10 11 12 import { utils } from \u0026#34;zksync-ethers\u0026#34;; // Here, `tx` is a `TransactionRequest` object from `zksync-ethers` SDK. // `zksyncProvider` is the `Provider` object from `zksync-ethers` SDK connected to the ZKSync network. tx.from = aaAddress; tx.customData = { ...tx.customData, customSignature: aaSignature, }; const serializedTx = utils.serialize({ ...tx }); const sentTx = await zksyncProvider.sendTransaction(serializedTx); Paymasters Paymasters时专门设计用来资助用户交易费用的账户，增强协议的可用性和灵活性，方便用户使用 ERC20 代币而不是 ETH 支付费用。\n与 Paymasters 交互 要使用paymaster，用户必须在其EIP-712交易中指定非零的paymaster地址，并在paymasterInput字段中指定相关数据。\nPaymasters 验证规则 验证规则尚未完全强制执行 不遵守这些规则的paymaster将来可能会停止正常运行 为了减少恶意paymaster潜在的 Dos 攻击，使用了类似于EIP-4337的声誉评分系统。但与EIP-4337不同，zksync 中的paymaster可以与任何存储 slots 交互，并且在特定条件下不会受到限制，如自上次成功验证以来经过的时间或连续的（consistent，可能也可以翻译为一致的） slots 访问模式\n内置 Paymasters 流程 paymaster可以自动操作或需要用户交互，这取决于其设计。例如将 ERC20 代币兑换成 ETH 的paymaster将要求用户授予必要限额。\n账户抽象协议本身是通用的，允许账户和paymaster实现任意交互。但默认账户（EOA）的代码不变，但人就希望他们能够参与自定义账户和paymaster的生态中。这就是为什么对交易的paymasterInput字段进行了标准化，以涵盖大多数常见的paymaster功能用例。\n你的账户可以自由选择实现或不实现这些流程的支持，但强烈建议保持 EOA 和自定义账户的接口相同。\n一般 Paymasters 流程 当paymaster不需要用户执行任何初始操作时，使用此流程：\npaymasterInput字段必须为具有以下接口的函数的调用进行编码：\n1 function general(bytes calldata data); 对于 EOA 账户，此输入通常不起作用，但paymaster可以根据需求进行说明（不太清楚这个函数具体有什么作用）。\n基于授权的 Paymasters 流程 当用户必须为paymaster设置 token 限额时，此流程十分重要。paymasterInput字段必须为对具有以下签名的函数的调用进行编码：\n1 2 3 4 5 function approvalBased( address _token, uint256 _minAllowance, bytes calldata _innerInput ); EOA 将确保支付给paymaster的_token的限额至少设为_minAllowance。_innerInput参数是一个额外的有效负载，可以发送给paymaster，以实现任意逻辑（如可以由paymaster验证的额外签名或密钥）。\n如果正在开发paymaster，则不应该相信交易的发送者会诚实行事（如通过approvalBased流程提供所需的限额）。这些流程主要作为对 EOA 的指示，而paymaster应始终仔细检查这些要求。\n测试网 Paymasters 为保证用户在测试网上体验到paymaster，同样继续支持使用 ERC20 代币支付费用，Matter Labs 团队提供了测试网paymaster，可以将 ERC20 代币与 ETH 以 1:1 的汇率（1 ERC20 代币等于 1 wei 的 ETH）支付费用。\npaymaster仅支持基于授权的paymaster流程，并要求token参数等于正在交换的token，并且minAllowance等于tx.maxFeePerGas * tx.gasLimit。此外测试网paymaster不适用_innerInput参数，因此不应提供任何内容（空bytes）。\n与 Paymasters 交互时估算 Gas 费用 由于额外的计算和操作，与paymaster的交互通常比标准交易消耗更多的gas，导致gas增加的主要原因是：\n内部计算：包括paymaster的validateAndPayForPaymasterTransaction和postTransaction的内部操作。 资金转账：paymaster将资金发送到bootloader时消耗的gas ERC20 token 限额的管理：是可选项产生的gas，如果用户使用 ERC20 代币补偿paymaster，管理代币的限额会消耗额外的gas。 用于内部计算的gas一般是最少的，具体取决于paymaster的实现 转移资金的成本与用户能为类似交易支付的费用相当 管理 ERC20 限额会显著影响gas的使用量，尤其是用户第一次设置限额。这个过程可能需要发布一个 32 byte 的存储密钥标识符，可能会以 50 gwei 的 L1 gas 价格使用多达 400k 的gas。需要注意，虽然交易流程在执行结束时，将存储 slot 清空（因此”授予X限额+paymaster花费所有限额），但初始成本是在执行期间预先收取的，只有在交易结束时 slot 归零后才会退款给用户。 准确估计 Gas 的重要性 准确的估计gas至关重要，尤其是对于涉及大量pubdata的操作，例如写入存储。你应该在估算过程中包含paymasterInput来保证准确考虑了paymaster的参与。以下代码片段来自定义的paymaster教程，演示了如何进行此估算：\n1 2 3 4 5 6 const gasLimit = await erc20.estimateGas.mint(wallet.address, 5, { customData: { gasPerPubdata: utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, paymasterParams: paymasterParams, }, }); 此处paymasterParams包括paymaster的地址和他的输入。然而paymasterInput通常包含难以提前预测的参数，例如用户所需的确切的代币数量。\n此外，paymaster可能需要验证价格数据或转换率，可能需要服务端的签名。\n处理复杂的依赖关系 对于如涉及依赖交易内容的这些签名的这种复杂依赖关系，产生了挑战：\n从validateAndPayForPaymasterTransaction中返回magic = 0可以模拟有效签名验证的gas消耗。这确保了尽管交易会由于magic = 0而在主网上失败，但仍旧可以估计出正确的gas数量。 gas的估算本质上时对防止交易失败的最低gas量的二分搜索。如果验证始终失败，那么gas估计也会失败，因为系统将不断尝试增加gas limit。 提供授权估算的策略 粗略估计：如果对于涉及的资金有一个大概的认识，用它来进行估计。由于缓冲已经包含在估计中，所以微小的差异通常不会导致交易失败。但如果用户的余额在估计和交易执行之间发生意外的变化，可能会出现差异 单独估计限额的设置：或者估算用户为交易的gas单独设置的限额。将此估算添加到原始交易的估算的成本中。这种方法考虑了 Nonce 的更改和一般验证逻辑，但可能会带来明显的开销。 每种方法都有其优点和缺点，选择正确的方法取决于交易的具体情况和paymaster的需求。\n签名验证 推荐的签名验证方法。如果项目准备支持原生 AA ，那么强烈建议这么做，这将允许自主的成千上万用户（许多新钱包都默认是智能账户，为用户提供更加流畅的体验）。我们预计未来会有更多用户转向智能钱包。\n建立的各种不同类型的帐户之间最显着的区别是不同的签名方案。我们希望帐户支持EIP-1271标准。\n@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol库提供了一种验证不同账户实现的签名方法。当需要检查账户签名是否正确时，强烈建议使用这个库。\n将库添加到项目中 1 npm add @openzeppelin/contracts 使用库的示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 pragma solidity ^0.8.0; import { SignatureChecker } from \u0026#34;@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol\u0026#34;; contract TestSignatureChecker { using SignatureChecker for address; function isValidSignature( address _address, bytes32 _hash, bytes memory _signature ) public pure returns (bool) { return _address.isValidSignatureNow(_hash, _signature); } } 验证 AA 签名 不建议使用ethers.js库来验证用户签名。官方 SDK 通过utils提供了两种方法来验证账户的签名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 export async function isMessageSignatureCorrect( address: string, message: ethers.Bytes | string, signature: SignatureLike ): Promise\u0026lt;boolean\u0026gt;; export async function isTypedDataSignatureCorrect( address: string, domain: TypedDataDomain, types: Record\u0026lt;string, Array\u0026lt;TypedDataField\u0026gt;\u0026gt;, value: Record\u0026lt;string, any\u0026gt;, signature: SignatureLike ): Promise\u0026lt;boolean\u0026gt;; 目前这些方法仅支持验证 ECDSA 签名，但很快将支持EIP-1271签名验证。这两种方法都会返回true或false，具体取决于消息签名是否正确。\n参考文章 ZKsync Era Protocol\n","date":"2024-08-08T17:54:47+08:00","permalink":"https://llwh2333.github.io/p/zksync-era-%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E6%8A%BD%E8%B1%A1%E8%B4%A6%E6%88%B7%E9%83%A8%E5%88%86%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91/","title":"zksync Era 官方文档抽象账户部分中文翻译"},{"content":"zksync Era 在 L1 有部署智能合约，以实现 L1 上的修改。部署的合约有：DiamondInit、DiamondProxy、DiamondUpgrade、ExecutorFacet、GettersFacet、MailboxFacet、Verifier、ValidatorTimelock、AllowList。\n通过上述合约，可以看的出来 zksync Era 的链上合约部分采用的是钻石代理方法，同时也有一些其他的合约辅助。\nDiamond 部分 这部分主要是直接贴近Diamond的部分，充当起了 L1（以太坊）与 L2 （ZK Chain）之间的连接器，负责检查提交的有效性证明（零知识证明）与数据可用性，处理 L1 \u0026lt;-\u0026gt; L2 的通信（存取款等），完成 L2 上的状态转换（zksync 的状态更替）。\nL2 部分也部署了一些重要的合约执行一些逻辑行为，这些合约被称为系统合约。\nDiamond 部分就是采用了EIP-2535的钻石代理，将各个功能划分为不同的切面（Facet）。zksync 的具体实现与参考实现的区别在于访问的冻结能力。每个Facet都有一个相关的参数，表示能否冻结对该Facet的访问。特权参与者可以冻结 Diamond（非单独的Facet），并且在主管（governor）或管理员（admin）解冻前，所有标有isFreezable的Facet都无法访问。\n需要注意的是，钻石代理的升级系统可以被冻结，从而永久冻结该钻石代理（我的理解是解冻需要升级，升级被冻结就死循环了）\nGettersFacet 单独的Facet，唯一功能是提供了view和pure方法，同时实现了loupe功能，方便了 Facet 的管理，该 Facet 绝对不能冻结。\nloupe功能就是指获取Diamond的有关信息（各个Facet的地址信息、函数选择器信息），进入到合约代码中发现函数的返回值大多数都是address类型。\nMailboxFacet 该 Facet 处理 L1 \u0026lt;-\u0026gt; L2 通信 ，具有三个功能：\nL1 \u0026lt;-\u0026gt; L2 通信：\n使数据和交易能够实现 L1 \u0026lt;-\u0026gt; L2 ，支持多层协议的实现（这个不懂） 桥接原生代币：\n允许 ETH 和 ERC20 代币桥接到 L2 上，使用户能在 L2 生态中使用这些资产 抵抗审查机制：\n还在研究中 L1 -\u0026gt; L2 通信的方法是：在 L1 上发起请求 L2 的交易并在 L2 上执行。这表示用户可以调用 L1 上的函数（如调用depositERC20函数，即向 L2 存入 ERC20 代币），然后相关交易数据将会保存在某个队列中（如priorityRequests队列），随后触发事件（让Watcher能够监听到，交给 L2 上的 zksync 处理）。\nL1 上 user 发起的Deposit和FullExit交易都可以独立于 L2 的交易，优先完成。\n用户在发起从 L1 到 L2 的交易时，需要以原生代币支付交易执行费用。在 L2 上的交易，由于 zksync 支持 AA 账户，所以可以用 ERC20 代币支付交易执行费用\nExecutorFacet 该 Facet 接收来自 L2 的 Batches，强制执行数据的可用性，检查零知识证明（zk-proof）的有效性。状态转换分三个阶段：\ncommitBatches（提交 Batches）\n检查来自 L2 的 Batches 的时间戳，处理 L2 的日志，保存 Batch 的数据，为 zk-proof 准备数据（对于 L1 上的合约，先接收到 Batches，再接收到 zk-proof，因为计算 zk-proof 需要时间） proveBatches（验证 Batches）\n验证 zk-proof executeBatches（执行 Batches）\n处理所有待处理的操作（完成优先请求），完成这个 Batches （官方文档中说的标记应该就是 L1 上抛出 event 吧，），同时也会用 L2 日志保存默克尔数根。 对于commitBatches，我们看看合约中的描述，正确符合上面的描述：\n1 2 3 4 5 6 7 8 9 10 /// @notice Function called by the operator to commit new batches. It is responsible for: /// - Verifying the correctness of their timestamps. /// - Processing their L2-\u0026gt;L1 logs. /// - Storing batch commitments. /// @param _lastCommittedBatchData Stored data of the last committed batch. /// @param _newBatchesData Data of the new batches to be committed. function commitBatches( StoredBatchInfo calldata _lastCommittedBatchData, CommitBatchInfo[] calldata _newBatchesData ) external; 每当提交一个 Batch 时，就会处理 L2 -\u0026gt; L1 的系统日志，每个 L2 -\u0026gt; L1 的系统日志都有一个 key 包含在下面中（对于源码中的多出的几个值我也不能理解为啥多出来了）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 对于给定的 Batch ，将会包含 9 到 10 个 系统日志，SystemLogKey 中每个键都会包含一个日志（log） enum SystemLogKey { L2_TO_L1_LOGS_TREE_ROOT_KEY,\t// L2_TO_L1_MESSENGER TOTAL_L2_TO_L1_PUBDATA_KEY,\t// L2_TO_L1_MESSENGER STATE_DIFF_HASH_KEY,\t// L2_TO_L1_MESSENGER PACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY,\t// L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR PREV_BATCH_HASH_KEY,\t// L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR CHAINED_PRIORITY_TXN_HASH_KEY,\t// L2_BOOTLOADER_ADDRESS NUMBER_OF_LAYER_1_TXS_KEY,\t// L2_BOOTLOADER_ADDRESS BLOB_ONE_HASH_KEY,\t// L2_PUBDATA_CHUNK_PUBLISHER_ADDR BLOB_TWO_HASH_KEY,\t// L2_PUBDATA_CHUNK_PUBLISHER_ADDR EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY\t// L2_BOOTLOADER_ADDRESS，仅在升级协议时需要 } L2_TO_L1_MESSENGER包含三个 key：\nL2_TO_L1_LOGS_TREE_ROOT_KEY TOTAL_L2_TO_L1_PUBDATA_KEY STATE_DIFF_HASH_KEY L2_SYSTEM_CONTEXT_SYSTEM_CONTRACT_ADDR包含两个 key：\nPACKED_BATCH_AND_L2_BLOCK_TIMESTAMP_KEY PREV_BATCH_HASH_KEY L2_PUBDATA_CHUNK_PUBLISHER_ADDR包含两个 key：\nBLOB_ONE_HASH_KEY BLOB_TWO_HASH_KEY L2_BOOTLOADER_ADDRESS包含两到三个 key：\nCHAINED_PRIORITY_TXN_HASH_KEY NUMBER_OF_LAYER_1_TXS_KEY EXPECTED_SYSTEM_CONTRACT_UPGRADE_TX_HASH_KEY AdminFacet 该 Facet 负责配置的设置和升级能力，可以处理一下任务：\n特权地址管理：\n更新关键角色，如验证者（Validator）、管理者（governor） 系统参数配置：\n调整关键的系统设置，如 L2 的 bootloader bytecode hash、Verifier 地址、Verifier 参数、费用配置 冻结能力：\n将Diamond执行冻结与解冻，以在升级期间或对检测到的漏洞响应来保护生态系统。 对 AdminFacet 的控制主要有两个实体实现：\nSTM（状态转换管理器）：\n单独的智能合约，用于协议升级时对系统执行关键更改。STM 的控制由Governance.sol合约和管理员实例控制。换个角度，Governance.sol由两个多签控制：管理员多签、安全委员会多签。通过协作，这些实例能够执行立刻升级的能力，而 Matter Labs 被限制为执行延时的升级。 管理员：\n由 Matter Labs 管理的多签智能合约，可以对系统执行非关键的更改，如授予 Verifier 权限。关于和治理的所有者是相同的多签。 DiamondInit 一个单独功能的合约，是钻石代理的初始化逻辑。仅在钻石代理的构造函数中调用以此，不会作为 Facet 保存在钻石中。\n函数会返回一个魔术值，如EIP 1271的设计，大小为 32 字节\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /// @notice hyperchain diamond contract initialization /// @return Magic 32 bytes, which indicates that the contract logic is expected to be used as a diamond proxy /// initializer function initialize(InitializeData calldata _initializeData) external reentrancyGuardInitializer returns (bytes32) { require(address(_initializeData.verifier) != address(0), \u0026#34;vt\u0026#34;); /* // ....... */ return Diamond.DIAMOND_INIT_SUCCESS_RETURN_VALUE; } /* 在 Diamond.sol 中的定义 bytes32 internal constant DIAMOND_INIT_SUCCESS_RETURN_VALUE = 0x33774e659306e47509050e97cb651e731180a42d458212294d30751925c551a2; // keccak256(\u0026#34;diamond.zksync.init\u0026#34;) - 1 */ ValidatorTimelock 介于 Validator 的 EOA 账户和 zksync 智能合约之间的智能合约，提供了无需信任的方法来延迟 batch 的执行，而无需修改主要的 zksync 合约。\nzksync 主动监控链的活动，并通过冻结链来对任何可疑活动做出应对，使得在恢复正常运营之前有时间进行调查和缓解措施。这种临时方案是为了防止网络处于 Alpha 阶段时验证器的热密钥泄露造成任何重大影响。\n该合约包含了四个主要函数：commitBatches 、 proveBatches 、 executeBatches 和 revertBatches 组成，只能由验证者调用。\n当 Validator 调用commitBatches时，相同的calldata传播到 zksync 合约（DiamondProxy通过call，在ExecutorFacet调用delegatecall），并且为这些 Batches 分配了一个时间戳，来跟踪 Batches 的提交时间，来强制实行提交与执行 Batches 之间的延迟。然后 Validator 可以证明早已提交的 Bacthes 无论写到的时间戳，并且再次将相同的calldata（与proveBatches函数相关）传播到 zksync 合约。在这个延迟过去后，验证者可以调用executeBatches将相同的calldata传播到 zksync 合约。\nValidatorTimelock 合约的所有者与管理合约的所有者都是 Matter Labs 多签。\n一些其他合约 Verifier 知识异序非交互式论证（PLONK）验证器拉格朗日基置换的修改版本（大概是链上进行零知识证明的验证的合约吧）。\nAllowList 存储在不同合约上调用函数的权限的智能合约。\n参考文章 zkSync 学习记录 2023.01.31\nZKsync Era Protocol\n","date":"2024-08-08T17:53:30+08:00","permalink":"https://llwh2333.github.io/p/zksync-era-l1%E5%90%88%E7%BA%A6/","title":"zksync Era L1合约"},{"content":"zksync 2.0 （后面简称 zksync）简单而言具体的，实现了 ZK Rollup 的项目，其采用了 ZK-SNARK 的零知识证明算法（经过 Boojum 升级后变为 ZK-STARK 的算法）。根据其官方所讲，其具有以下特点：\n可靠的安全性（继承自以太坊的安全性），对第三方零依赖（这个没看懂） 无需许可的 EVM 兼容智能合约（不理解无需许可的意思） 保留关键的 EVM 功能，如智能合约的可组合性 标准的 web3 API 通过交易输出，即状态差异进行状态更新（这中方式更加节省成本） 原生的抽象账户 总体 对于 zksync 的架构组成，可以分为几个部分：\nzkSync 智能合约：\nzksync 部署了 Solidity 合约在 L1（以太坊）网络上，作为 ZK Rollup 的链上部分组件。负责管理用户的 balance（余额）并验证证明者提交的零知识证明与更新状态，同时实现以太坊与 zksync 的交互（存款、取款、跨层消息传递） zkSync Prover：\nProver 是一个按需的 worker（需求量大（即 Server 负载高）的时候有多个，不需要（即没有交易输入）的时候没有），可以为一个有效区块生成零知识证明 proof，以此证明链下处理的交易的正确性，然后将证明交给 Server，由 Server 交给链上合约，保证合约只接收有效的交易。 由于生成零知识证明 proof 需要大量的计算，所以作为 Prover 的机器需要有强大的 CPU 与大量的 RAM。 zkSync Server（服务程序）：\nServer 就是 zksync 的网络节点，负责维护链下状态，将交易聚合为 batches，将密封的 batches 发送到链上。具体而言具有以下功能：\n监测智能合约的链上操作（如存款，取款） 接收 zksync 交易 生成 zksync 的区块 为有效区块发出 proof 生成申请 将数据发布到 zksync 的合约上 ZK Circuits（应该就是具体的 ZKEVM 吧）：\nCircuits 的这些电路时复杂的数学结构，代表了可验证的计算逻辑。其负责确定什么可以被验证为有效的 proof。对于 zksync ，Circuits 定义了 EraVM 运行的计算规则，定义了交易的执行方法。 总体概览（取自官网）\n参考文章 ZKsync Era Protocol\nDapp-Learning ZKsync Era Tutorial\nzkSync 学习记录 2023.01.31\n","date":"2024-08-08T17:52:10+08:00","permalink":"https://llwh2333.github.io/p/zksync-%E4%BB%8B%E7%BB%8D/","title":"zksync 介绍"},{"content":"Rollup 可以说是根据 Plasma 的方案升级而来：在主链上部署 Rollup 合约记录链下状态并且负责验证提交的链下状态，Rollup 链上的运营商则是负责维护好链下的状态。\n对于 Rollup 用户而言，其与主链的交互在两个时候：进入（将 L1 的资产存入 L2）与退出（从 L2 中取出资产到 L1 中），其余时候是在 Rollup 上进行的，而在 Rollup 上进行交易的花费小于直接在主链上进行交易的花费，同时也能减轻主链的负担（Rollup 会将多个 Rollup 的交易打包一起交给主链，相当于 N 个交易合并为 1 个交易）。\n其总体流程就是：用户在 Rollup 上产生交易（这会修改账户的状态，例如余额减少），Rollup 上的运营商将交易纳入区块，最终生成对应的默克尔树，并将汇总交易（batch，压缩后的交易集合）与交易后的状态（state root，默克尔树根）记录在链上（即主链上预先部署好的智能合约），并由链上负责验证。\n其中如何实现验证根据不同的思路有了不同的方向：ZK Rollup（提交状态时验证）、Optimistic Rollup（提交状态后验证）。\n前者的思路是有效证明（证明区块是有效的），通过名为零知识证明的方法提交一个区块的证明，这个证明可以在不泄露交易内容的情况下证明交易的状态变更的正确，链上的合约在通过默克尔树、证明进行验证，通过验证就固定了链下的状态变更（这就表示 ZK Rollup 的上主链时间需要看 ZK 证明的生成速度）。\n后者的思路是欺诈证明，其假设区块是 Optimistic（乐观）的，即假设区块中没有欺诈区块，然后设置一个争议期，在争议期内任何用户都可以对这个区块发起挑战（认为这个区块有问题），提交自己的欺诈证明。如果争议期内没有人提出挑战，那么区块则会通过状态变更（这就表示交易真正的上链时间就是争议期时间长度）。\nOptimistic Rollup OR 并没有节省交易的存储消耗，因为其将交易和交易结果一并上传到链上，这正是为了保证数据可用性的问题（Plasma 放弃的原因正是因为交易全部存储在链下，导致了数据可用性问题）。\n目前 Optimistic Rollup 的方案的落地并不只一个，而是有着众多的 OR 项目，主要是因为各个项目对于方案里面的部分偏具体的部分有不同的实现思路，因此产生了不同的项目。\n目前主要的 Optimistic Rollup 项目有：Arbitrum、Optimism、opBNB 和 COMBO 这几个项目。\nOptimism Optimism 是一个 EVM 等效的 Optimism Rollup 链（简称 OP）。其中主要包含两类节点：sequencer（排序器）和 verifier（验证器）。\n两者负责不同的任务：sequencer 负责将用户提交的交易进行处理，排序，然后提交给 L1 ，verifier 负责对于提交到 L1 上的状态根，汇总交易进行验证，如果验证为有问题则会提交对应的欺诈证明，sequencer 会因此需要重新计算对应的状态根。\nOptimism 和 Arbitrum 的区别主要提现在对争议（挑战的验证方法不同）\n对于争议的处理，Optimism 主要依靠欺诈证明，需要证明就需要重新执行该交易以证明交易结果的正确，为了实现这个重放 Optimism 实现了 OVM 来处理，在 OVM 1.0 中 采用的是非交互式欺诈证明，而 OVM 2.0 中采用的是交互式欺诈证明（Arbitrum 也式非交互式）。\nArbitrum Arbitrum 与 Optimism 很相似，主要区别在于争议处理（就是上面的那个证明挑战方式，Arbitrum 采用了交互式的方法）。\n在这个交互式证明挑战中，将整个块上的交易分为 k 个部分（每个部分都有一个起点与端点），然后挑战者与被挑战者相互交流这 k 个部分确认争议点在哪个部分，然后继续缩小，直到确认具体的哪一条指令是两者的争议，然后交由 L1 合约判定。\n目前 Arbitrum 项目包含了几个具体的项目：\nArbitrum One ：基于 Optimistic Rollup 技术，主要面向 Defi 和 NFT。 Arbitrum Nova：采用了 ZK-Rollup 技术，主要用户高吞入量的应用（如游戏、社交等应用） ZK Rollup 前面讲过了，ZK Rollup 是通过零知识证明的方式进行打包验证的，其与 Optimistic Rollup 的不同点是这个验证，在 ZKR 中，提交到链上的信息有：状态 A 和 B、零知识证明、汇总交易，这些信息表示：状态 A 在经过这些汇总交易之后会变成状态 B，你可以通过验证零知识证明来证实。因此在 ZKR 中没有等待时间（Optimistic Rollup 有等待时间），ZKR 现在没有完全击败 OR 的原因在于生成 ZK 证明的时间。\n目前主流的零知识证明算法有：Bullet proof、zk-SNARK、zk-STARK\n而主要的 ZKR 的项目有：zkSync、StarkWare 、Polygon（zkEVM）、Scroll、Aztec\n在介绍各个项目前，先了解下目前对于以太坊兼容性 zkEVM（可以执行与以太坊虚拟机 (EVM) 相同的高级编程语言或低级字节码的虚拟机，并使用零知识证明 ZKP 证明此代码，这些类型的虚拟机更准确的名称是有效性证明生成 EVM）的类型。\n下面是由 Vitalik 提出的分类方法\n第一类：完全等同于以太坊的 ZKR\n在所有部分完整复制以太坊（目前没有任何 zkEVM 实现了） 第二类：完全等同于 EVM 的 ZKR\n等效于 EVM ，但非完全等效于以太坊，能完全兼容现有应用，但对以太坊进行了微小的修改，以使开发更加容易（Scroll、Polygon（zkEVM）都是理论上如此） 第三类：几乎等同于 EVM 的 ZKR\n比起第二类牺牲了更加多的等效性，证明生成的更快（Scroll、Polygon（zkEVM）实践上属于此类） 第四类：高级语言等效\n能够接收用 Solidity 语言写的合约，转换为另一种语言（自定义、适用于 zk 的）。（zkSync、StarkNet） zkSync zkSync 有两个版本：zkSync 1.0 （zkSync Lite）和 zkSync 2.0 （zkSync Era）。在 zkSync 1.0 中其只支持简单交易，zkSync 2.0 则在外观与使用都类似于以太坊，其智能合约采用 Solidity/Vyper 编写的，并且可以使用与其他 EVM 兼容链相同的客户端来调用，采用的零知识证明算法是：zk-SNARK。\nzkSync 2.0 有以下特点：\n是一种通用协议 强大的 LLVM 编译器，兼容支持 Solidity 语言（第四类 ZK Evm） 以 ETH 支付 gas 费 原生账户抽象 StarkWare StarkNet 则是前面第四类 ZK Rollup，其采用的是 zk-STARK 的零知识证明算法，被认为比 SNARK（zkSync 采用的） 更有效和可扩展，但可能需要更复杂的技术设置。\nStarkNet 中支持智能合约，但需要采用 Cairo 语言编写，作为第四类 ZK Rollup，其并不会在 EVM 中执行，而是在自己建立的 VM 中执行，使用自定义的字节码。\nScroll Scroll 是实现了与 EVM 等效的 ZK Rollup，这意味着我们可以很轻松的将以太坊上的程序迁移到 Scroll 中（即不需要更改太多的代码）。其计划通过构建 1:1 opcode 映射来实现支持 EVM opcode 从而直接接受 EVM opcode 而无需编译器。\nScroll 的架构包括一个集中式序列化节点和一个分散的证明网络。\n集中式序列化节点负责对交易进行排序、创建区块，并将交易数据作为 calldata 提交到以太坊上的 Rollup 合约以供数据可用性。Scroll 计划逐步去中心化序列化节点。\n同时，一个名为 Roller 的分散式证明生成器会产生证明并将其发布到 L1 网络上，利用分布式计算能力。Rollers 是随机选择的，可以在不同的 Rollers 上并行生成不同块的多个证明以增加速度。\nPolygon（zkEVM） Polygon zkEVM 是 Polygon 收购了 Hermez Network 开始开发一个结合了 STARK 和 SNARK 的安全性和效率的 EVM 等效系统。其使用自定义的语言 zkASM 来解释 zkEVM 代码。\n参考文章 第六章：Layer2 实现方式之 Rollup\n什么是 Rollup？\u0026ndash;上篇\n什么是 Rollup？\u0026ndash;下篇（zk-rollup）\n白话 Rollup\nLayer2 赛道分析：Optimistic Rollup 技术为基础的项目探讨与市场对比\n第十四章：Optimistic Rollup 代表项目 arbitrum\n第十五章：Optimistic Rollup 代表项目 optimistim(Boba, Metis\nOptimism Rollup - Dora Dōjo\nArbitrum\nzkEVM 方案一览：简析 zkSync、StarkNet、Polygon zkEVM 、Scroll\n全方位解读 Arbitrum 及其生态，何以成为 Layer2 领跑者？\n一览 7 大主要的 L2 网络：它们各自有哪些优势和潜力？\nzkSync 2.0: zkEVM 的公共测试网已上线！\n","date":"2024-08-08T17:51:01+08:00","permalink":"https://llwh2333.github.io/p/rollup-%E4%BB%8B%E7%BB%8D/","title":"Rollup 介绍"},{"content":"区块链中存在的这样一个不可能三角：去中心化、安全性、可拓展性。在区块链刚诞生的时候，去中心化和安全性得到了很好的实现，但随着发展区块链交易成交的速度开始跟不上了，其中 Crypto Kitties一度让以太坊不堪重负，交易拥堵。对于不修改区块链本身代码，而在现有的链本身上面搭建东西从而达成拓展的方法就是 Layer2 拓展。这种思路目的就是为了在尽可能保证去中心化和安全性的情况下提高可拓展性。\n根据实现的设计方向出现了一些分支：侧链、状态通道（State Channel）、Plasma、Rollup。\n侧链 侧链就是建立一个独立的区块链，这个链有独立的共识机制（即主链是什么共识机制与侧链无关），其通过双向锚定进行沟通，对于主链而言，它是感知不到侧链的存在的，而侧链又具有一定的独立性（主链崩溃并不会影响他的运行，只会影响他的价值）。\n双向锚定就是两个链之间的一个沟通，通过一方销毁代币，另一方生成等值代币，从而实现资产的跨链转移。\n对于侧链这一概念是需要搭配主链才有的（即有两条链才能称得上主链和侧链），单独看链是没有侧链这一说法的。如我们复制以太坊代码搭建一条链，和真正的以太坊之间搭建起一个双向锚定，那么自建的链就可以称为侧链（我感觉因为其价值低所以才称作侧链），真以太坊链就是主链。\n状态通道 状态通道这个方法就像在两个用户之间建立一个账本一样：创建初记录两者状态，一系列交易后，又得到一个两者状态的最终情况，销毁账本的时候上传这个最终情况的状态。\n举个例子就是，A 和 B 之间有一系列交易：\nA -\u0026gt; B（10 ETH） B -\u0026gt; A（2 BTC） A -\u0026gt; B（5 WETH） B -\u0026gt; A （30 ETH） 状态通道就是记录 A 和 B 交易开始时候的余额情况，然后根据交易不断修改双方状态，当关闭时返回交易完成的状态，让区块链根据状态通道返回的结果进行这场交易的结算。\n在这个过程中只有开启交易（启动状态通道）和结算交易（销毁状态通道）是在链上进行的，而中间的一系列交易在链下进行的，这使得，这种方法适合交易对象固定且交易频率高的用户，这样能为用户省下大量交易费用，同样让主网上的交易大大减少。\n但同样存在一些缺点，最明显的就是智能合约问题，这种方法只能转账交易，无法实现智能合约的交互，此外还有其他缺点如：拓展性差、参与双方需要保持在线等缺点。\nPlasma 在 Plasma 中，就是通过创建不同的子链（用于支持不同的业务需求），然后将主链上的交易执行交给子链进行，交易数据也会存储在子链上，但会定期将子链的状态根上传到 L1 主链上，从而实现链的扩容（链下）。\n在上面的描述中，主要有几个问题：如何将交易执行交给子链、子链如何保证能将正确的状态同步到主链当中。\n首先是交易执行如何交给子链。首先就是 Plasma 在主链上部署一系列智能合约用于锁定用户在在主链上的数字资产与保存、验证子链状态（默克尔树根）。用户将自己的资产发送给 Plasma 的智能合约，然后子链就会产生等值的资产给这个用户。用户就可以在子链上进行交易，如此就实现了将交易执行交给子链。\n其次是子链如何保证能将正确的状态同步到主链当中的问题，这其实包含了几个子问题：\n如何验证子链中出现恶意行为 如何保证子链中出现恶意行为时，保证用户不会受到损失 如何惩罚出现的恶意行为 验证子链中出现的恶意行为首先是需要理解什么是子链中的恶意行为。在子链中能出现的作恶者有两个：用户 Alice 和运营者 Operator（负责创建和发布区块）。\n当 Alice 想作恶时（实现双花），他想以自己账户余额更多时的状态进行提款，意图忽视后来的交易，以此向主链提出退出 Plasma 子链（需要包含一笔退出押金）。主链接收申请后放入列表，等待争议期结束。在争议期期间 Bob 发现了 Alice 的恶意行为，对于 Alice 的余额发起争议（Challenge，提交该笔余额被花费的证明），当主链验证发现 Bob 的争议是正确的，那么 Alice 的提款失败，同时他的退出押金被发送给 Bob。\n当 Operator 想作恶时，主要就是发布了恶意区块（没有正确履行自己的义务），这可能有下面的情况\nOperator 发布区块中包含这样的交易：Alice 向 Bob 转账 1 token，实际上 Alice 余额为 0 Operator 发布无效区块进行数据可用性攻击 Operator 故意排除拖延某些交易 Plasma 的安全性主要依靠争议（用户提供欺诈证明，主链来进行裁决）保证，欺诈证明的提供需要链下完整的区块，而一旦 Operator 拒绝提供完整区块，那么欺诈证明就无法生成了， Operator 甚至能盗取用户财产。\n例如：Operator 私自把 Alice 的币转给 Bob ，再从 Bob 处转给 Eve，最后 Eve 进行提款（实际上 Bob 和 Eve 都是 Operator 的账户）。其中 Bob 转给 Eve 的交易可以公开展示，但对于 Alice 转给 BoB 的交易数据扣留，那么人们就无法证明 Eve 的资金有问题，因为 Eve 的资金有问题需要溯源证明 Alice 转账给 Bob 的交易有问题（需要指出这笔交易的数字签名有问题），而 Operator 并没有发布完整的区块（我的理解是默克尔树叶子节点对应的交易的完整数据没有全部展示），人们就无法证明这个 Alice 给 Bob 的交易有问题。\n对于这些 Operator 作恶，就需要用户及时退出了（官方作恶，只能跑路了）。\n通过以上描述，优点无需描述了（就是链下扩容的那些优点），缺点就是：\n挑战期，这个既给了解决恶意交易的办法，但也使得正常用户的体验很差了 运营者， Plasma 链中子链状态同步到主链上依靠一个运营商，而运营者可以轻松的进行数据可用性攻击 用户在线，Plasma 要求交易资产的所有者在场 Rollup 在上面的描述中，我们可以知道 Plasma 存在着众多问题，所以在此基础上又出现了 Rollup 这一改进方法。Rollup 的设计方向和 Plasma 很相似：通过将大量交易数据打包（rollup）并与状态根一起提交到以太坊主网，以此让以太坊对提交状态验证提高交易吞吐量和降低交易费用。\n个人感觉 Rollup 和 Plasma 的区别就是增加了打包（Rollup）这个部分，并因此以太坊的对于子链的验证方法也有了一些改变。\n目前对于 Rollup 的实现又分为两个路线：OP（Optimistic Rollup）、ZK（Zero Knowledge Rollup）。首先我们知道 Rollup 最需要解决的就是数据可用性的问题和交易有效性问题，解决这两个问题就保证了 Rollup 的安全性。而 OP、ZK 就是用于解决这个问题的。\nOP 则是采用乐观验证机制，其假设提交的数据都是正确的，然后这次状态的提交存在一个质疑期，用户可以提交欺诈证明来质疑这次状态，证明成功，链上智能合约将会回滚不正确的区块。ZK 则是采用了零知识证明的方法，只有链上的智能合约检查提交的数据和零知识证明，检查通过后，状态提交则认为是有效的。\n参考文章 以太坊 Layer2 扩容方案之 State Channel\n以太坊 Layer2 扩容方案之 Sidechain\n以太坊 Layer2 扩容方案之 Plasma\n以太坊 Layer2 扩容方案之 Rollup\n以太坊 Layer2 扩容方案之 Validium\nValidium 与 Layer 2 的设计空间\nWeb3 系列教程之进阶篇\u0026mdash;1. Layer 2\nRollup 为何能成为当下最火的 Layer2 方案\n以太坊扩容方案 Rollup 学习指南\n以太坊 Layer2：Rollup 战争\n系统解读 ZK-Rollup、Optimism-Rollup 以及 Plasma\nDA 与欺诈证明：Plasma 不支持智能合约的原因\n","date":"2024-08-08T17:48:46+08:00","permalink":"https://llwh2333.github.io/p/layer-2-%E6%8B%93%E5%B1%95%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","title":"Layer 2 拓展简单认识"},{"content":"Compound V2 也和 Aave V2 很相似，有部分区别，但感觉是很多地方相似的，采用的设计逻辑都是由很多相似的地方的。下面依旧从行为的方面进行介绍。\n借贷 Compound 的借贷没有像 Aave V2 那样有闪电贷、浮动利率借贷、稳定利率借贷那么多种，只有一个浮动利率借贷。\n和 Aave V2 的逻辑整理一样，借贷也从借款、还款、清算三件事情出发。\n借款 当一个用户想要从 Compound 中借款时需要进行抵押（这是毫无疑问的），而 Compound 采用的借款策略同样时超额抵押借贷（和 Aave V2 一样），而衡量这个超额比例的就是抵押因子（超额抵押的比例）。借款会有这么一个流程：用户借出一笔钱，开始计算利息，等待用户还款，等待过程中还会检查用户的借款是否可能造成坏账（即是否需要清算）。\n我们知道 Aave V2 就是采用的复利的方式计算，而 Compound 也是一样。在 Compound 中是怎么计算个体用户的利息呢？这是通过复利累计指数计算的（$FV$ 表示当前累计指数，$PV$表示上次累计指数）：\n$$ FV = PV * (1+x)^{t} $$\n那么合约中是怎么实现的呢？每当用户想借一笔款时，先计算复利累计指数（也算是更新当前复利累计指数），然后记录下来，然后开始计算自己的债务，如果过去没有结果款，那么这个债务大小就是当前借款大小，如果过去有债务，那么就用到了一个公式：$\\frac{FV}{PV}$，表示借款的增长（从 PV 时刻开始产生的利息加上借款本金的比例）。这个公式展开后起始就是：$(1+x)^t$，其中 $t = \\Delta T$ 表示从借出到当前经过的时间，其中 $x = \\overline{R_{borrow}}$ 表示这段 $\\Delta T$ 时间的平均利率。通过这个公式（PV 即为上次借款时记录的累计指数，FV 即为当前累计指数）乘上过去债务大小，就得到过去欠款的最新大小。两者（新借款和过去借款）相加，即为总债务。最后更新池子中得债务（为了下次更新池子得利率）。\n通过上述，我们就可以理解每次借款了，当我们想知道当前实际欠款大小也是利用上面更新过去债务最新大小的思路。（$\\frac{FV}{PV} * last_{borrow}$ 后者表示上次 Compound 内部记账的金额大小，如此得到欠款总数）\nCompound 的借款采用的抵押物实际上是 ctoken（一种 ERC20 代币，用户存款可以获得对应的ctoken，存 ETH 得 cETH），即用用户的存款作为抵押物进行贷款。\n还款 还款在 Compound 中既可以还自己得欠款也可以还他人得欠款（这个就是清算）。我们在借款中知道通过抵押物（ctoken）可以获得标的 token，还钱就通过归还标的 token赎回ctoken。在 Aave V2 中采用了债务token（一种魔改 ERC20）记录用户债务，而 Compound 则是内部记账（变量记录地址欠款额度）得方式。\n当用户归回欠款时，先计算复利累计指数（更新归还前得利息情况，和前面一样），然后计算过去债务得最新大小，然后减去还款得到最后得债务大小，并存入（总债务这些得也会更新），最后合约将还款转入资金池中。\n清算 前面说了，清算就是帮别人还欠款，但人们不会做慈善一样得帮忙还款，清算者需要获得一定得利益。\n首先需要明确的时清算条件。前面借款时有说到抵押因子，将用户存款乘以抵押因子就得到所能借出的贷款上限，随着抵押物的价格波动和贷款的利息所带来的贷款增加，这就可能导致用户借款达到贷款上限，从而到达清算条件。\n其次是清算人如何来清算的。需要明白的是对于被清算人（借款人）的债务，单次清算上限为债务 50% ，因为清算人也不一定是恶意不还款（可能是币价波动导致清算这些的）。同时对于清算人所获得的抵押资产（ctoken）也是可选的（如果借款人有多种抵押物），可以选择更加青睐的代币类型的抵押物。清算人清算就是通过购买借款人手中的ctoken（即购买对应的token）来替借款人偿还债务，以此进行清算。\n那么清算让借款不再处于坏账风险的原因是什么？直接的理解就是超额抵押借贷中的超额让这笔借贷交易处于清算状态，合约通过清算（自动卖出用户的ctoken）实现欠款的偿还，合约只要卖出的价格超过超额抵押的判断下的价格高，即可让交易不再处于坏账风险中。实际上合约是以接近市场价的价格卖出的。\n清算人的收益是什么？前面说合约是以接近市场价的价格卖出的，这个接近就是清算人的收益。这个售出价比市场价低，中间的差价便是清算人的收益。具体的计算如下：\n$$ seizeTokens = \\frac{Amount_{Repay} * liquidationIncentive * price_{Borrowed}} {price_{Collateral} * exchangeRate} $$\n分子：清算人帮还欠款数额 _ 清算奖励（合约为 1.08 ，这两个相乘，放大清算人付出的金额，让清算人能以低于市场价的价格购买）_ 借款人借出资产的价格。\n分母：抵押物的价格（清算人想要获得的token的价格）* 兑换率（ctoken兑换token的比例）\n兑换率的存在主要是因为存款中的存款人的利息收益的计算。\n存款 在 Compound 中，存款和 Aave V2 一样，都是根据借款所产生的利息而获得存款利息。有借款产生利息，那么用户存款才会有存款利息收益产生，如果 Compound 中没有人进行借款，那么无论往里面存多少钱都不会有利息。\n借款产生的收益会分为两部分：一部分给用户作为存款收益，另外一小部分留给合约，作为资金储备池（防止出现取款的挤兑）。\n首先需要明白，在 Compound 中存入token会获得一定数量ctoken，而取出的时候也就是利用ctoken换回token，而利息就是存入和取出时两者兑换比例不同所带来的不同。\n存入 用户 Compound 中存入一笔金额为 m 的token代币，此时该类型的token的兑换率为$ER$ （token：ctoken = 1toekn：nctoken），那么用户可以拿到 $\\frac{m}{ER}$ 个ctoken。\n随着 Compound 池子中的资金不断被借出，这个兑换率会不断上升，这会使得后来的用户采用同等量的token得到的ctoken更加少，实现了从时间上区分用户的存入（这样同样量的token，无论是否同一用户，只要时间不同存入获得的ctoken不一样），而无需记录其他的信息。\n那么这个兑换率是怎么变动实现单调递增的？首先是兑换率的定义：\n$$ ER = \\frac{Count_{t}}{Count_{ct}} $$\n其中 $Count_t$ 表示资金池中的token总数（不包含资金储备池）即：$underlyingBalance + totalBorrowBalance - reserve$，最后的减号便是去除储备池的金额。\n其中 $Count_{ct}$ 表示发行的ctoken数量。当用户存入 m 的代币，我们可以看到兑换率的变化：\n$$ ER = \\frac{Crount_t + m}{Count_{ct} + m * \\frac{Count_{ct}}{Crount_t }} = \\frac{Crount_t + m}{Count_{ct} * (1+ \\frac{m }{Crount_t })} = \\frac{Crount_t + m}{\\frac{Count_{ct}}{Crount_t} * (Crount_t+ m )} = \\frac{Count_{t}}{Count_{ct}} $$\n可以看到并不会减小汇率，这至少保证了存款不会导致兑换率下降，而借贷毫无疑问只会使得 $ER$ 不断上升。\n取出 现在来看看取出，取出就是存入的反向操作，燃烧ctoken，然后根据兑换率获得token，燃烧 m 个ctoken可以获得 $m * ER$ 个token。\n下面来看看这个过程对于兑换率的影响（其实就是看会不会让兑换率下降）：\n$$ ER = \\frac{Crount _ {t} - m * \\frac{Count _ t}{Count _{ct}} }{Crount _ {ct} - m} = \\frac{Crount _ {t} - m * \\frac{Count _ t}{Count _{ct}} }{Crount _ {ct} - m} = \\frac{Crount _ {t} * (1 - \\frac{m}{Crount _ {ct}})}{Crount _ {ct} - m} = \\frac{Crount _ {t} * (Crount _ {ct}- m)}{Crount _ {ct} * (Crount _ {ct}- m)} = \\frac{Count _ {t}}{Count _ {ct}} $$\n我们可以看到兑换率并没有改变，所以兑换率只会单调递增。\n参考文章 剖析 DeFi 借贷产品之 Compound：概述篇\n剖析 DeFi 借贷产品之 Compound：合约篇\nCompound​ 中文白皮书\n关于借贷的思考 - 以​compound 为例\nhttps://github.com/Dapp-Learning-DAO/Dapp-Learning/blob/main/README-CN.md（这个真的很好）\n","date":"2024-08-08T17:41:45+08:00","permalink":"https://llwh2333.github.io/p/compound-v2-%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/","title":"Compound V2 逻辑整理"},{"content":"Aave 就相当于去中心化交易所中的一个银行，在其中用户可以进行一系列的资金操作，下面基于行为的角度对其两个功能进行阐述：借贷、存款。\n借贷 在 Aave 中借贷有两种方式：借款（有抵押物的）、闪电贷（无抵押物的）。\n闪电贷 Aave V2 的闪电贷感觉没有什么特别的地方，就是在一个区块交易内完成借出和还入两个操作。\n1 2 3 4 5 6 7 8 9 function flashLoan( address receiverAddress, // 借款受益人地址 address[] calldata assets, // 借款代币地址（数组） uint256[] calldata amounts, // 借款数量（数组） uint256[] calldata modes, // 借款模式（数组） address onBehalfOf, // 还款人地址 bytes calldata params, // 入参编码 uint16 referralCode // 推荐码 ) external override whenNotPaused { 查看 Aave V2 的代码（参考上述的函数头），我们可以知道，Aave V2 允许一次性借出多种贷款（assets是个数组），并且允许选择模式（由modes决定，不同资产可以选择不同模式），有：闪电贷模式（0，正常闪电贷）、借款模式（1，普通的借款，采用稳定利率；2，普通的借款，采用浮动利率）。\n对于每一笔贷款（无论哪种模式） Aave V2 都会先转出借款费用、计算手续费，然后再根据模式进行判断：\n闪电贷：从贷款者处（receiverAddress）转账还款（借款+手续费） 借款模式：执行借款的函数逻辑 总的来说，Aave V2 在闪电贷种添加了一个转入正常借贷的机会，可以将闪电贷、正常借贷合并在一笔交易中。\n借款 关于借款，就开始麻烦起来了，借款可以分为三个部分：借款（借钱这件事）、还款（还钱这件事）、清算（清算合约中不良借款这件事）\n清算 我们首先来看看清算这件事。由于区块链中没办法轻易的溯源到账户拥有者本人，所以对于合约中每一笔借款都不能有坏账（借出款的价值大于抵押物的价值）这件事发生合约就会不被信任了。\n我们知道合约对于借款策略采用的是超额抵押借贷（如抵押 100$价值的抵押物，借贷的钱不能到达 100$ 那么多，可能只有 50$）,所以可以设定一个阈值（抵押物价值/所欠金额），到达一定比值后资产就会被清算（合约自动卖出抵押物，借款人就不用还款了）。\n那么这个清算阈值是怎么确定的呢？Aave V2 定义了一个健康系数(HealthFactor)，当其小于 1 时，该笔交易就可以清算。那么这个HealthFactor如何定量呢？\n$$ HealthFactor = \\frac{TotalCollateralInETH * LiquidationThreshold}{TotalDebtInETH} $$\n首先分母TotalDebtInETH表示：总共的债务量（借款 + 利息，但在实际中只会计算债务量，因为 Aave V2 采用的是利滚利模型）。分子TotalCollateralInETH表示：借款人抵押物的总价值（以ETH为单位）。分子LiquidationThreshold表示：该种资产设定的阈值（一个百分比，例如 75%）。\n分子两者相乘，得到当前抵押物能借出金额上限，分母表示当前借出的债务。分子受市场波动影响，抵押物价值下降，HealthFactor就有可能逼近 1 了，而TotalDebtInETH由于债务利率的存在，会不断的上涨，也会让HealthFactor逐渐的逼近 1 。\n清算具体会发生什么呢？当用户抵押了价值 200 $的抵押物，借出了 100 USDT，此时清算阈值是 75%，那么抵押物的价值如果下跌，最多跌倒 133.3（用 100 / 0.75 得到，并且忽略利息对健康系数分母的影响），一旦跌倒这个价格之下，那么清算开始发生。\n此时有一个清算人负责清算该资产，它可以清算该笔资产的一部分（用户自己决定，但有上限，由 Aave V2 决定，其不允许一次性清算完全部抵押资产），Aave V2 将对抵押物折价卖出，清算人付出借出债务的代币（0%~Aave V2 规定的上限 50%），以当前折扣价买入被清算的抵押物（(市场价/代还款)*(1+奖励比例)，其中奖励比例就是清算人比起在正常市场中购买代币，在 Aave V2 清算中能额外获得的利润）。此时借款人的健康系数受到影响，变得健康：以上清算行为相当于 Aave V2 自动帮借款人卖出一部分抵押物，来偿还借款（略低于市场价，但高于阈值 * 市场价，因此可以提高健康系数）。\n如何发起清算呢？合约由于不能说根据触发条件自动执行函数，所以需要外部的套利者不断的巡视整个市场，发现这些可以清算的交易，对于到达清算线的交易，所有人都可以对其进行清算。清算过后：套利者获得一定利润（通过奖励比例），合约避免了坏账的诞生，维护了市场的稳定。\n借款 Aave V2 对于借款人的债务进行了token化，即债务就是一个个的代币。首先有一个问题：债务是token那么转移token是不是就不用还钱了。理论是这样的，但是 Aave V2 将transfer函数重载了，调用后就会revert，所以是没办法转移债务的。\n然后就是如何借款了。在 Aave V2 中借款有两种：稳定利率债务、可变利率债务。前者利率固定，借钱时利率是多少，后面利滚利时利息就一直是多少（也有可能调整，如借钱时固定利率和当前利率差距过大）；后者利率不固定，随着市场波动，借钱的人多（资金池使用率高），利率就高，人少，利率就低。\n当我们想统计t时刻债务总量即：$D^{asset}_t = SD_t(稳定利率债务) + VD_t(浮动利率债务)$，而借款关系到存款利率问题（借款为合约赚取收入，收入分配给存款用户，实现银行的基本功能）。\n浮动利率债务 浮动利率虽然浮动（会因为资金池利用率而改变，利用率高，浮动利率就该，反之变低），但是其计算实现反而更加简单。Aave V2 对于每一笔可变债务都首先放缩到0时刻（创世时间）然后利用一个变量存储累计可变债务指数，从而统计出用户当前总可变债务（仅浮动利率债务部分）。\n首先理解这个放缩（scaled），它将当前借出的债务换算到创世时间时（即假设你这笔债务在创世时间时借出），假设现在是 $t_1$ 时刻，从 $t_0$ 时刻（创世时间）到当前的累计可变债务 $VN_t^{asset}$ 为 200%（假设创世初借款 100，现在 $t_1$ 就需要还 200 了），那么用户借出 1000 $ 相当于创世初时借了 500 $。上述这个 1000 到 500 的过程就是放缩。\n然后就是这个累计可变债务指数 $VN_t^{asset}$ 又是如何确定的呢？白皮书中的定义是：\n$$ V N_t = (1 + \\frac{V R_t}{ T_{year}} )^{ ∆T} *V I_{t−1} $$\n下面介绍公式中的每个变量的定义，首先是 $VR_t$ 表示的是：当前浮动利率（这种当前利率放到最后阐述，先默认已知），即当前所有浮动债务所需要每秒支付利息的利率，这个利率是年华利率。$T_{year}$ 表示：一年的秒数（固定值），配合其分子进行除法运算，即可得到每秒的利率。$\\Delta T$ 表示：前后两次操作发生之间的间隔时间，这个操作包含借出、存入、取出、偿还、交换、清算。$VI_{t-1}$ 表达的含义应该与 $VN_t^{asset}$ 一样（我认为的），因为两者白皮书上定义公式一致：\n$$ V I_t = (1 + \\frac{V R_t}{ T_{year}} )^{ ∆T} *V I_{t−1} $$\n而其初始值应该为 1 ，然后随着用户不断的操作使得这个变量单调递增。每当我们借出一笔价值为 m 的债务，然后合约进行放缩得到债务值$\\frac{m}{VN_t} $ ，然后加上过去放缩到创世时间的债务（这种方式方便合约计算债务，只需要改变这个累计值，不然浮动利率不断变动，每次操作都要遍历所有债务计算新的债务，又或者记录每次利率变化，gas消耗太大）：\n$$ ScVB_{t}(x) =ScVB_{t-1}(x) + \\frac{m}{VN_t} $$\n当我们想知道当前债务到底是多少时，也很容易计算（其中 $x$ 指某个用户，$VN_t$ 在白皮书中为 $D_t$，查了下资料说可能是白皮书排版错误，$D_t$ 表示放缩后总债务，包含了浮动和固定的）：\n$$ V D(x) = ScV B(x) * VN_t $$\n对于开头的 $SD_t$ （浮动利率债务）的计算就是所有用户的 $VD(x)$ 的总和了。\n稳定利率债务 对于稳定利率，其计算方法就不一样了。首先需要明确，稳定利率债务不是说借贷利率恒定不变（非硬编码在合约中），而是在计算复利（利滚利）时，利率固定下来，不会因为资金利用率（合约中资金使用程度）而改变，当然当前稳定利率还是会不断改变的。\n那么借出一笔稳定利率的债务是怎么进行的呢？在 Aave V2 中记录的是用户的平均稳定借款利率和稳定借款债务，通过两者即可计算当前债务量。\n为什么要计算平均稳定借款利率呢？如果使用平均稳定借款利率，那么统计债务的时候就需要遍历每一笔稳定利率借款，而且每一笔债务都需要单独的存储，这都会需要大量的gas，而采用平均稳定利率，那么对于每个用户想要得到当前时刻的债务 $SD_t(x)$，需要存储的就变为，用户所有债务的平均稳定利率 $\\overline{SR_t}$ 和稳定利率债务总量 $SB(x)$：\n$$ SD_t(x) = SB(x) * (1 + \\frac{\\overline{SR_t}}{T_{year}})^{\\Delta T} $$\n上述公式另外几个变量的含义都比较清楚，与浮动利率中的一致。那么上面的平均稳定利率这些变量是怎么确定的呢？首先是平均稳定利率 $\\overline{SR_t}$ ，作为平均的利率，肯定是稳定利率平均而来，其公式为：\n$$ \\overline{SR_t} = \\frac{SD_t * \\overline{SR_{t−1}} + SB_{new} * SR_t}{SD_t + SB_{new}} $$\n上述公式表示，当用户借出一笔新的资金 $SB_{new}$ ，在此时，资金池的稳定利率为 $SR_t$ ，而用户此前的稳定利率债务为 $SD_t$ （不包含 $SB_{new}$，并且个人觉得使用 $SD_{t-1}$更加符合含义）此前的平均稳定利率为 $\\overline{SR_{t−1}} $。在初始和还清债务时，用户的 $SD_t$ 和 $\\overline{SR_{t−1}} $ 均为 0 。如此，如果用户不断借钱，那么这个平均稳定利率就会不断靠近当前稳定利率。\n在上面的几个公式中 $SD_t$ 和 $SB(x)$ 不断交替出现，其含义十分相似，都表示用户的稳定利率的债务，但还是有一些区别。对于 $SB(x)$ 其表示的存储于合约上的债务，即用户当前拥有的债务 token，而$SD_t(x)$ 更多的表示实际需要还给合约的欠款，从$SB(x)$ 到 $SD_t(x)$ 需要经过开头的那个公式。\n还款 浮动利率还款 在前面我们知道，统计用户的浮动利率债务的时候用的是放缩后的债务 token，而还款也是一样，扣除的是放缩后的债务 token，以此保持浮动利率债务的统计。那么还款后应该扣除多少放缩后的债务 token 呢？这个逻辑和借款的逻辑相反，用户还款 $m$ 根据从创世到现在的累计可变债务 $VN_t^{asset}$ 即可得到新的债务：$ScVB_t(x) = ScVB_{t-1}(x) - \\frac{m}{VN_t}$。\n稳定利率还款 稳定利率和浮动利率不同，没有这个放缩的过程，所以是计算当前实际欠款 $SD_t(x)$（利用借款中其定义公式），然后减去还款数额，并且重新计算平均稳定利率（分母不能为 0 所以分条件）：\n$$ \\overline{SR*t} = \\begin{cases} 0 \u0026amp;, if \\space SDt − SB(x) = 0 \\\\ \\frac{SD_t * \\overline{SR*{t−1}} − SB(x) * SR(x)}{SD_t−SB_x}\u0026amp;,if \\space SD_t − SB_x \u0026gt; 0 \\end{cases} $$\n存款 Aave V2 中对于用户的存款也是采用放缩和 token 的方法存储用户的存款额度。首先是用户查看当前存款额度$aB_t(x)$（能取出多少钱）：\n$$ aB_t(x) = ScB_t(x) * NI_t $$\n其中 $ScB_t(x)$ 正是用户放缩后的存款额度（同样是放缩到创世时间），而后面的 $NI_t$ 正是累计流动性指数，和借款里的累计类似，这是一个全局的变量（所有的存款共用）：\n$$ LI_t = (LR_t * \\Delta T_{year} + 1 ) * LI_{t-1} \\ LI_0 = 1 * 10^{27} = 1 \\space ray $$\n上面阐述了这个累计指数的初始值和后续的变化方法，而其中的 $LR_t$ 是指当前的流动性（一个随着每次资金池操作而改变的值）。在上面我们看到了这个累计流动性指数也是和可变债务指数一样，在不断的单调递增，利用放缩到创世初的存储金额两者结合计算当前存款。\n当用户新存入一笔存款 m 也是放缩到创世初，然后两个相加，取款类似（具体是按照取款额度还是放缩后的代币额度需要后续看源码）：\n$$ ScB_t(x) = ScB_{t-1}(x) + \\frac{m}{NI_t} $$\n利率变化 在上述的各种操作，我们可以知道 Aave V2 其实挺像一个银行了，利用用户的存款进行出借，赚取借贷的利息，然后将利息作为存款的利息发放给存款用户，实现存款获得利息，借款付出利息（虽然是超额抵押借贷）。\n但还有一个问题，上述的三个实时利率（当前稳定利率、当前浮动利率、当前流动性率）都是如何确定的呢？首先明确影响这些利率的因素：资金池使用率（使用率越高，借贷的利率理所当然的会更高，反之降低）。\n基本上说所有的操作都会影响这个，然后影响其他：借款拉高、还款降低、存款拉低、取回拉高。同时借贷的利息越多，用户存款所得到的利息才会高（存款利息的来源就是借贷的利息）。\n首先明确借款的当前利率如何确定：\n$$ \\sharp R_t^{asset} = \\begin{cases} \u0026amp;\\sharp R^{asset}_{base} + \\frac{U^{asset}_t}{U^{asset} _ {optimal}}* \\sharp R^{asset} _{slope1}\u0026amp;, if U^{asset} _t \u0026lt; U^{asset} _ {optimal} \\\\ \u0026amp;\\sharp R^{asset} _ {base} + \\sharp R^{asset} _ {slope1} + \\frac{U^{asset}_t − U _{optimal}}{1−U _{optimal}} * \\sharp R^{asset} _{slope2}\u0026amp;, if \\space U^{asset} _{t} ≥ U_{optimal} \\end{cases} $$\n我们知道借款分为浮动和稳定，而上述公式同时适用于两种，将其中的 $\\sharp$ 替换成为V或S即表示浮动和稳定两种。上面的式子表达的意思是：利率从 $\\sharp R^{asset} _ {base}$ （由管理员设置）开始起步计算（相当于起步价），根据当前的资金使用率 $U^{asset} _ t $ （总债务/总储蓄）判断，如果小于最佳借款使用率 $U^{asset} _ {optimal}$（由管理员设置），基础利率加上对应比例slope1（由管理员设置）的利率（$\\frac{U^{asset} _ t}{U^{asset} _ {optimal}} * \\sharp R^{asset} _ {slope1}$）。超过最佳借款使用率 $U^{asset} _ {optimal}$ 就在基础利率和slope1利率的和上，根据超过对应比例的slope2（由管理员设置）的利率（$\\frac{U^{asset} _ t −U _ {optimal}}{1−U _ {optimal}} * \\sharp R^{asset} _ {slope2}$）递增。\n而存款利率（即流动性利率），理所当然的根据债务所产生的利息决定：\n$$ LR_t = \\overline{R_t} * U_t $$\n其中 $U_t$ 是资金池的使用率，$\\overline{R_t}$ 是总体借款利率，总体借款利率通过计算浮动债务和稳定债务的得到：\n$$ \\overline{R_t} =\\begin{cases} \u0026amp;0\u0026amp;, if \\space D_t = 0 \\\\ \u0026amp;\\frac{V D_t * V R_t+SD_t *\\overline{SR_t}}{D_t} \u0026amp;, if \\space D_t \u0026gt; 0 \\end{cases} $$\n参考文章 AAVE v2 - white paper\nAAVE V2 学习笔记\nDapp-Learning: AAVE\n","date":"2024-08-08T16:25:27+08:00","permalink":"https://llwh2333.github.io/p/aave-v2-%E9%80%BB%E8%BE%91%E6%95%B4%E7%90%86/","title":"Aave V2 逻辑整理"},{"content":"V2 中手续费的提取很直接：根据 LP 提供者手中的 LP token 在总量的占比，提取出池子中对应比例的两种代币，这时候获得代币总量中包含了手续费和开始时投入的代币（忽略无常损失）。\n在 V3 中采用了自选区间，通过头寸进行记录流动性，通过计算区间内每单位流动性获得手续费和用户流动性得到应该获得的手续费。\n单位手续费 想要计算区间内单位手续费，首先需要知道的是当前区间有多少流动性，因此 V3 在tick上设置了两个变量liquidityGross、liquidityNet（计算区间内流动性就是计算两个tick间的流动性）。\nliquidityGross：当该tick被设置为区间上限或下限时就会增加，当其为 0 时，表示该tick没有人设置区间（计算区间流动性时忽略，当这个tick不存在）。 liquidityNet：记录流动性的变化量，即一个$\\Delta$值，每当穿过这个tick值时需要改变的当前激活流动性大小（从tick右边穿过加，反之减）。 liquidityNet计算方法：\n注入流动性，tick 是价格下限，liquidityNet 减少 l 注入流动性，tick 是价格上限，liquidityNet 增加 l 移除流动性，tick 是价格下限，liquidityNet 增加 l 移除流动性，tick 是价格上限，liquidityNet 减少 l 通过上述变量，我们便获得了当前区间的激活流动性，根据交易中产生的手续费，我们可以得到因为这笔交易产生的每单位流动性手的续费收益。\n那么后续如何做呢？如果直接记录到各个提供者账上，那么需要遍历该区间所有提供者（可想而知这会产生多少gas，没人会想承担这个成本的），这个思路没了。\n无需遍历的方法便是：新产生的手续费收益会修改的只有全局总收益（所有区间相加的手续费收益总和），而想计算当前交易区间内收益：全局收益 - 区间外收益（每次交易不会影响这个值）。\n当然上述只是一个思路，那么具体一点如何设计呢？\nV3 中设置了一个变量feeGrowthGlobal记录全局单位手续费收益，利用每个tick记录该tick外的手续费feeGrowthOutside。这样一来我们就能得到范围内的手续费：feeGrowthInside = feeGrowthGlobal - feeGrowthOutside。\n这里又有两个问题：如何为不同时间投入流动性的用户计算各自的收益？tick如何记录外部手续费收益（怎么定义外部）？\n首先是时间问题，投入流动性时，头寸记录当前区块手续费收益feeGrowthInside，因为这是一个累加值，当取出时和当时的feeGrowthInside比较增量，就知道该段时间内的收益了。\n其次是外部收益记录问题，这里抛去了绝对的外部的定义（不再区分点的左边是外部还是右边是外部），而是通过当前价格点来调整这个外部值。假设当前价格点在tick左边，tick中记录了一个外部值，此时外部就是tick的右边，里面的值就是tick右边的收益。\n当价格点穿过tick时，tick的左边就变为外部，tick所记录的外部收益怎么算呢？feeGrowthOutside(新的) = feeGrowthGlobal - feeGrowthOutside(旧的)。\n把手续费收益看作图形面积，全局就是总面积，原本的就是点右边的图形总面积，相减后就是左边的总面积，而这左面积就包含了这期间交易产生的新的手续费收益。\n关于tick添加流动性时初始化，没找到相关资料，等以后看看白皮书再补充。\nLP 提供者的流动性 对于 LP 提供者提供的流动性是怎么定量计算的呢？\n首先时原本的恒定乘积公式：$x * y = k = L^2$\n用户指定区间，实际相当于讲这条曲线向左下方移动，使得 $x_1、y_1$ 作为与坐标轴相交的一段曲线 图片参考：Understand UniswapV3 whitepaper的图二图三\n这就变成了一个新的公式（根据左加右减，上加下减）：$(x + x1) * (y + y1) = L^2$\n我们根据公式 $y = p * x(p 为价格)$联合 $x * y = L^2$ 得到 $x = L / \\sqrt{p}\\space;\\space y = L *\\sqrt{p}$，所以 $x_1 = L / \\sqrt{p_{upper}}\\space;\\space y_1 = L *\\sqrt{p_{lower}}$，所以我们可以得到\n$$ (x + \\frac{L} {\\sqrt{p_{upper}}}) * (y + \\frac{L} * \\sqrt{p_{lower}}) = L^2 \\ \\space \\ \\space \\ L = \\sqrt{(x + \\frac{L} {\\sqrt{p_{upper}}}) * (y + \\frac{L} * \\sqrt{p_{lower}})} $$\n参考文章： Understand UniswapV3 whitepaper\n","date":"2024-08-08T16:22:18+08:00","permalink":"https://llwh2333.github.io/p/uniswap-v3-%E6%89%8B%E7%BB%AD%E8%B4%B9%E6%94%B6%E5%8F%96/","title":"Uniswap V3 手续费收取"},{"content":"主要更新点 分不同价格区间提供流动性 提供多个收费层级 高级预言机 价格区间提供流动性 V3 采用了一种新的方式给用户进行流动性的区间选择提供：对于ETH/DAI池可以选择将 100 美元价值的代币分配给 1,000-2,000 美元的价格区间，并将另外 50 美元价值的代币分配给 1,500-1,750 美元的区间。\n用户选择投入流动性到 1,000-2,000 美元的价格区间，那么只有价格在此范围内进行的交易产生的手续费，用户才有资格得到。因此用户需要选择交易最经常发生的价格区间才能获得最大的收益\n如此做法带来了什么好处呢？最直接是资金的利用率提升了：过去 V2 中池子中有部分不合理的价格也被强制分配了一部分流动性（如 1 eth = 0.1$或者1 eth = 10^18$），这无疑是对池子的资金的浪费，V3 通过用户指定流动性提供区间，提高了这个利用率（如果用户非要选择离谱的区间那用户就没办法获得手续费，毕竟那些区间没有交易产生）。\n采用这种区间的方法就需要修改一些原本 V2 的设计了：首先就是 LP token。\n在 V2 中采用的是 ERC20 代币作为 LP token，因为所有流动性添加用户添加的流动性是等价的（大家都是在零到正无穷这个区间添加流动性）。而到了 V3 就很明显的不一样了：每个用户选择的区间并不一定一样（也可以一样，但这种情况应该少数，即使是某些池子中大多一样，那也不影响），所以它们获得 LP token 无法等价起来，故采用 ERC721 来记录流动性提供者投入的流动性，而这个 LP token 也被称为头寸。\n对于用户选择的区间和当前池子的价格之间的大小关系不同，有不同的投入要求（此处假设价格点连续）：\n价格大于区间：假设此时：1Y = 10X，提供者选择的区间为：1：20、1：30，那么此时想添加流动性，就只能添加代币X。（可以理解为认为X币会跌/Y币会涨，设置一个订单，在此范围内逐渐卖出/买入代币，当然前提是超出你设置的区间后及时取回流动性，不然随着价格回来又会转换回来） 价格在区间内：假设此时：1Y = 10X，提供者选择的区间为：1：5、1：20，那么此时想添加流动性，需要同时注入两种代币 价格小于区间：假设此时：1Y = 10X，提供者选择的区间为：1：5、1：7，那么此时想添加流动性，就只能添加代币Y。 其次的设计就是区间：区间的选择不能无限制，作为链上合约，实现不了这么复杂的事情。\nV3 在价格这一射线上选择一系列不连续的价格点作为可以选择形成区间，这些价格点称为tick，以此来减少计算关于流动性的计算，然后还设置了tickspacing这一存在，要求两个tick之间存在tickspacing个tick，而在 V3 中锁定唯一的代币对池子，需要通过：两种代币、tickspacing这三个参数。tick的大小是如何设置的呢？tick本身是一个等幂数列 $p_i= {1.0001}^i$ ，其 i 的取值有范围[-887272, 887272]。这使得在接0-1的时候能提供一个很密集的tick（很适合如稳定币对），远离 1 的时候能提供较分散的tick给价格波动大的兑换合约（如两个山寨币对）。\n多收费层级 V3 新增的多收费层级就是指不同档次的手续费，V2 中所有代币对合约的手续费统一0.3%，这对于某些合约（稳定币对合约）收费太高，某些合约（山寨币对合约）收费低了些（币价波动大，很容易贬值）。V3 就因此设置了不同的手续费档次。\n不同的收费层级通过前面所讲的tickspacing结合决定：手续费低，则币价相对稳定，tickspacing小；反之手续费高，币价波动大，tickspacing大。具体设置如下：\n费率 tickspacing 建议的使用范围 0.05% 10 稳定币交易对 0.3% 60 适用大多数交易对 1% 200 波动极大的交易对 在 V3 合约实现的时候为tickspacing扩充留下了代码，可以后续添加。\n高级预言机 V3 中提出一个新的计算平均价格的方法，与 V2 的预言机有所不同，但总体思路还是相近的。\n在 V3 中tick的计算为$p_i= {1.0001}^i$，所以$i = \\log _{1.0001} p_i$\nV3 中计算的不再是价格累积值而是tick累积值，所以$a_j = a_{j-1} + \\Delta t * i$，其中 i 就是上面tick中指代的那个 i 。当我们计算平均价格时\n$$ P_{t1,t2} = \\frac{a_{t2} - a_{t1}}{t2 - t1} = \\frac{\\sum_{i =t1}^{t2}\\log_{1.0001}P_i}{t2 - t1}=\\log_{1.0001}{(\\Pi _{i = t2}^{t_2} P_i)^{\\frac{1}{t2 - t1}}} $$\n最后面那一步转换便称为价格 的几何平均值形式（数学不好，没能理解这个转换）。剩下的计算和 V2 也很相似了\n参考文章：\nUniswap v3 详解（五）：Oracle 预言机\nUnderstand UniswapV3 whitepaper\n","date":"2024-08-08T16:18:10+08:00","permalink":"https://llwh2333.github.io/p/uniswap-v3-%E5%8D%87%E7%BA%A7%E6%A6%82%E8%BF%B0/","title":"Uniswap V3 升级概述"},{"content":"关于错误，是每个编程语言避不开的部分。在solidity中一旦出现异常，则当前交易将会回滚（即相当于没有发生过，除了你的 gas 被消耗了）。\nsolidity里抛出异常的方法有三种：\nerror require assert 对于可能出现异常抛出的地方，solidity也提供了try-catch方法进行异常捕获处理。\n1 error error是solidity 0.8.4新加的内容，方便且高效（省gas）地向用户解释操作失败的原因，同时还可以在抛出异常的同时携带参数，帮助开发者更好地调试。\n使用error需要用户自己定义error类型和抛出的参数，同时需要搭配revert使用。例子如下：\n1 2 3 4 5 6 7 8 9 10 11 error TransferNotOwner(); // 自定义error function transferOwner1(uint256 tokenId, address newOwner) public { if(_owners[tokenId] != msg.sender){ // revert 将会返回后面的一个数值，同时回滚交易 // 在 0.8.4 后允许抛出 error 错误，帮助调试代码 // revert 会剩余的 gas 返回调用者 revert TransferNotOwner(); } _owners[tokenId] = newOwner; } 2 require require命令是solidity 0.8之前抛出异常的常用方法，根据条件判断是否抛出异常require(检查条件，\u0026quot;异常的描述\u0026quot;)。优点是好用，缺点是随着require后返回的字符串的长度的增加，gas费用也在增加，比error高。例子如下：\n1 2 3 4 function transferOwner2(uint256 tokenId, address newOwner) public { require(_owners[tokenId] == msg.sender, \u0026#34;Transfer Not Owner\u0026#34;); _owners[tokenId] = newOwner; } 3 assert assert命令一般用于程序员写程序debug，因为它不能解释抛出异常的原因（比require少个字符串）assert(检查条件)。最大的缺点是条件不成立后，抛出异常且gas用回全部消耗掉。例子如下：\n1 2 3 4 function transferOwner3(uint256 tokenId, address newOwner) public { assert(_owners[tokenId] == msg.sender); _owners[tokenId] = newOwner; } 4 try-catch 在solidity 0.6版本后，solidity也添加了异常处理方法，并且try-catch只能被用于external函数（只能由外部调用的函数）或创建合约时constructor（被视为external函数）的调用。基本语法如下：\n1 2 3 4 5 6 7 8 9 10 try externalContract.f() { // call成功的情况下 运行一些代码 } catch Error(string memory reson){ // 这里一般是 require/revert 的异常抛出，毕竟参数是 string // call 失败的情况下 运行一些代码 } catch (bytes memory reason) { // assert 的异常抛出 // catch 失败的 assert() emit CatchByte(reason); } 5 总结 现在真正使用的异常抛出方法有：error（新兴）、require，而assert由于其高费用而常常不予考虑。\n对于异常捕获tyr-catch只能在调用外部函数（包括生成新合约）时使用。\n","date":"2024-08-08T16:12:08+08:00","permalink":"https://llwh2333.github.io/p/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%A4%E8%AF%86/","title":"异常处理的简单认识"},{"content":"ABI (Application Binary Interface，应用二进制接口)是与以太坊智能合约交互的标准。说人话就是：给智能合约阅读的编码标准。\n为了应对智能合约中不同的情况，就有了不同的编码方法（合约要求的输入不一，还有省空间的问题）。关于编码方法如下：\nabi.encode abi.encodePacked abi.encodeWithSignature abi.encodeWithSelector 关于解码方法如下：\nabi.decode 1 abi.encode abi.encode会根据给定的 ABI 规则进行编码（将每个参数填充为 32 字节的数据，并拼接在一起）。当我们与合约进行交互时，使用的就是abi.encode。使用方法如下：\n1 2 3 4 function encode() public view returns(bytes memory result) { result = abi.encode(x, addr, name, array); } // 其中的四个参数随用户决定 返回值为bytes类型。\n2 abi.encodePacked 由abi.encode的编码规则可以看出，其中很容易浪费的空间。当我们想节省空间，并不与合约进行交互时，就可以使用abi.encodePacked。abi.encodePacked会使用参数所需的最低空间编码（如uint8参数就不会占用 32 字节那么大的空间了），使用方法同abi.encode。\n返回值为bytes类型。\n3 abi.encodeWithSignature abi.encodeWithSignature的规则和abi.encode类似（每个参数都时 32 字节），但区别在于Signature（函数签名）这个上。abi.encodeWithSignature的第一个参数要求是函数签名，调用其他合约时可以使用，例子如下：\n1 2 3 function encodeWithSignature() public view returns(bytes memory result) { result = abi.encodeWithSignature(\u0026#34;foo(uint256,address,string,uint256[2])\u0026#34;, x, addr, name, array); } 返回值为bytes类型。返回结果相当于原本abi.encode例子中的结果加上函数选择器 32 字节化结果。\n4 abi.encodeWithSelector 与abi.encodeWithSignature功能类似，只不过第一个参数为函数选择器，为函数签名Keccak哈希结果的前 4 个字节。\n1 2 3 function encodeWithSelector() public view returns(bytes memory result) { result = abi.encodeWithSelector(bytes4(keccak256(\u0026#34;foo(uint256,address,string,uint256[2])\u0026#34;)), x, addr, name, array); } 返回值为bytes类型。返回的结果与abi.encodeWithSignature中一致（对于相同的函数）。\n5 abi.decode abi.decode用于解码abi.encode生成的二进制编码，将它还原成原本的参数。使用方法如下：\n1 2 3 function decode(bytes memory data) public pure returns(uint dx, address daddr, string memory dname, uint[2] memory darray) { (dx, daddr, dname, darray) = abi.decode(data, (uint, address, string, uint[2])); } 6 总结 最基本的ABI编码方法就是abi.decode，但为了节省空间（在不与合约交互时）设计了abi.encodePacked。\n为了快捷计算所需要的合约交互编码结果，设计了abi.encodeWithSignature和abi.encodeWithSignature，其中前者填入的是函数签名字符串参数，后者使用的是函数选择器，但输出结果一致。\n","date":"2024-08-08T16:09:24+08:00","permalink":"https://llwh2333.github.io/p/abi-%E7%BC%96%E7%A0%81/","title":"ABI 编码"},{"content":"以太坊中外部账户EOA可以创建账户，同样智能合约也可以创建账户。智能合约创建账户的方法有两种：\ncreat creat2 1 creat 使用creat就是直接new一个合约即可，使用create创建的地址的计算方法是对：部署者地址和nonce（部署者发送交易的总数）进行哈希计算。使用方法如下：\n1 2 3 4 5 6 7 Contract x = new Contract{value: _value}(params) // Contract 是要创建的合约名（两个 Contract 都是） // x 是返回的合约对象（地址） // 如果构造函数是 payable，可以创建时转入 _value 数量的 ETH // params 是新合约构造函数的参数 新地址 = hash(创建者地址, nonce) 使用creat同样也需要知道需要创建合约的代码\n2 creat2 使用creat2的目的是为了让合约地址独立于未来的事件（不管未来区块链上发生了什么，你都可以把合约部署在事先计算好的地址上）。地址计算方法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 新地址 = hash(\u0026#34;0xFF\u0026#34;,创建者地址, salt, hash(bytecode)) // 0xFF 一个常数，避免和 CREATE 冲突 // 创建者地址 // salt 由创建者提供的数值 // bytecode 待部署合约的字节码 // 计算如下（貌似还是可以直接在合约中使用）： predictedAddress = address( uint160(\t// 再转为 uint160（address 类型为 uint160 的长度） uint(\t// 先转为 uint256 keccak256(\t// 对所有输入进行哈希 abi.encodePacked(\t// 进行编码打包 bytes1(0xff),\t// 固定的字节 address(this),\t// 部署者的地址 salt,\t// 由部署者自己决定 keccak256(type(Pair).creationCode)\t// 访问 Pair 的内存字节数组，creationCode 只能在内联汇编中使用。 ) ) ) ) ); 使用creat2的方法如下（只是多添加了一个salt参数）：\n1 2 3 4 5 6 7 8 9 Contract x = new Contract{salt: _salt, value: _value}(params) // 在汇编中调用 assembly { // 1：0 表示发送的 wei 数 // 2、3： 表示字节码在内存中的位置 // 4：表示盐值 addr := create2(0, add(bytecode, 0x20), mload(bytecode), salt) } 3 总结 对于creat和creat2来说，两者间除了creat2可以提前计算出将要部署的合约的地址外，没有什么区别。\n","date":"2024-08-08T16:03:11+08:00","permalink":"https://llwh2333.github.io/p/%E5%90%88%E7%BA%A6%E5%86%85%E7%9A%84%E5%90%88%E7%BA%A6%E5%88%9B%E5%BB%BA/","title":"合约内的合约创建"},{"content":"1 合约变量 ​ 通过创建或调用合约变量即可使用其他合约中的变量\n1 2 3 4 function callGetX2(address _Address) external view returns(uint x){ OtherContract oc = OtherContract(_Address); x = oc.getX(); } ​ 其中 OtherContract 就是我们想调用的合约名字，_Address 就是目标合约被部署后的址。\n这种方法要求：已知目标合约的代码（或接口）和地址。\n调用者修改了，执行环境被修改\n2 call ​ address 类型低级成员函数，返回(bool, data)，分别对应 call 是否成功以及目标函数的返回值。\n​ call 使用后调用者（msg.sender）被修改，执行环境也修改为目标合约的执行环境。可以指定发送给目标合约的 value 和 gas。\n​ 不推荐使用它来调用其他合约，因为不安全（因为这回将函数调用的主动权交给它），但其可以帮助我们在不知道目标合约代码（或接口）的情况下调用其函数。使用方法如下：\n1 2 3 address.call{value：x,gas:y}(data) // data 为二进制编码 // address 是目标合约地址，即想调用这个合约的函数 其中的 data 是使用 abi.encodeWithSignature 获得的，其值为对调用函数和函数参数内容的编码。\n​ 当调用了不存在的函数时，会触发目标合约（address）的 fallback 函数，这存在安全风险。\n3 delegatecall ​ 与 call 类似，为 address 类型低级成员函数，返回值也和 call 类似，但其只能指定 gas，不能指定 value。\n​ delegatecall 使用后调用者（msg.sender）和执行环境均不变。\n​ 使用 delegatecall 一定要保证当前合约和目标合约的状态变量存储结构相同，并且目标合约安全，不然会造成资产损失。\n​ 使用其场景主要有代理合约和 EIP-2535 Diamonds。使用方法如下：\n1 2 3 address.delegatecall{value：x,gas:y}(data) // data 为二进制编码，也是用 abi.encodeWithSignature 获得的 // address 是目标合约地址，即想调用这个合约的函数 4 callcode ​ 与 call 类似，为 address 类型低级成员函数，返回值也和 call 类似，使用后调用者（msg.sender）会修改，执行环境不会改变。\n在 solidity 0.5.0 后禁用了。\n5 staticcall ​ 它允许合约调用目标合约的函数和数据，但不能修改（即只能调用 view、pure 函数）。\n目前 solidity 中没有 API 能够直接调用它，仅仅是计划将来在编译器层面把调用 view 和 pure 类型的函数编译成 STATICCALL 指令。\n6 总结 ​ 主要能够使用的有三种（call、delegatecall、合约变量），有一种废弃（callcode），一种未来计划用在编译器层面中（staticcall）。\n​ 几种方法可以这样记：call 方法属于‘极端改变’的方法，调用者和执行环境均改变；delegatecall 方法属于‘极端不改变’的方法，调用者和执行环境均不变；callcode 方法改变调用者，但执行环境不变；合约变量方法要求高（多了个目标合约代码或接口的要求），但安全。\n","date":"2024-08-08T14:53:55+08:00","permalink":"https://llwh2333.github.io/p/%E5%90%88%E7%BA%A6%E5%86%85%E7%9A%84%E5%90%88%E7%BA%A6%E8%B0%83%E7%94%A8/","title":"合约内的合约调用"},{"content":"问：SSL 链接建立过程中，密码套件、证书、密匙协商算法到底是怎样的？ 答：\n​ SSL 链接的建立过程可以分为 4 个阶段：\n服务端与客户端交换信息（双方发送 Hello 信息）：SSL 版本、随机数、会话 ID、密码套件（密钥交换算法、MAC 算法、加密算法）、压缩方法（可选） 服务端向客户端发送信息：服务端证书（证书链）、服务器公钥（可选，视密匙协商算法定，如对于 RSA 算法，其证书中已包含公钥 ，而 DHE 要，DH 不用）、客户端证书请求（可选）、服务器握手完成信号 客户端向服务端发送信息：客户端证书（如果第二步有请求）、客户端交换预主密钥（用服务器公钥加密）、客户端证书验证（可选，若有发送客户端证书才需。客户端会将所有收到信息进行 hash 并用私匙签名） 客户端向服务端发送两条信息，服务端发送相似信息：更换加密规约（事件消息，表示本链接以后使用约定的加密方式通信）、Finish 消息（将 Handshake 信息、主密钥 进行 hash 所得值） ​ 密码套件在第一步中出现，确定了密钥协商算法、MAC 算法、加密算法。\n​ 证书在第二部分出现，有签名验证功能（有的证书还包含服务端公钥，如 RSA、DH、ECDH，就有了加密功能）。\n​ 密钥协商算法在第一步确定好，后面的阶段则使用该算法交换信息，最后得到一个通信双方都知道，没有第三方知道的密钥。\n参考资料： SSL 协议详解知识库博客园 (cnblogs.com) 问：密码套件的格式是怎样的？ 答：\n​ 例如：TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA ，表示使用 TLS 协议，采用的密匙协商算法为：带有 RSA 的 ECDHE 算法；采用的加密算法为：AES（密匙与初始向量为 256）；采用的 MAC 算法为：SHA\n参考资料： SSL 协议详解知识库博客园 (cnblogs.com) SSL 证书(HTTPS)背后的加密算法 - 首席咨询 - 博客园 (cnblogs.com) 问：密匙交换算法有哪些？如何进行的？ 答：\n​ 密匙交换算法的作用在于能够安全的帮助通信双方交换密匙（即使有第三方可以监听双方所发出的所有消息内容）。 ​ 算法的分类有：RSA 算法（基于大整数的因数分解问题）、DH 算法（基于离散对数问题）、ECDHE 算法（基于椭圆曲线离散对数问题），利用算法交换密匙的过程如下： ​ RSA 算法：\n服务端直接发送自己 RSA 算法的公匙给客户端 客户端用服务器公匙加密自己密钥发送给服务端 服务端用自己私匙解密信息得到客户端的密钥 ​ DH 算法：\n双方利用固定的值：p、q 客户端和服务端都进行一样的操作：各自生成一个不同的随机数 X ，得到一个对数 N = $q^X$ ，发送给对方 客户端和服务端收到一个 N （两个值显然不一样），再进行计算 KEY = $N^X$ ，此时明显两者的 KEY 都是一样的，故获得了密匙 ​ ECDHE 算法：\n客户端随机生成随机值 $R_a$，计算 $P_a(x, y) = R_a * Q(x, y)$，$Q(x, y)$ 为全世界公认的某个椭圆曲线算法的基点。将 $P_a(x, y)$ 发送至服务器 服务器随机生成随机值 $R_b$，计算 $P_b(x,y) = R_b * Q(x, y)$ 。将 $P_b(x, y)$ 发送至客户端。 客户端计算 $S_a(x, y) = R_a * P_b(x, y)= R_a * R_b * Q(x, y)= S$ ；服务器计算 $S_b(x, y) = R_b *P_a(x, y) =R_b * R_a * Q(x, y) = S$ 算法保证了 $S_a = S_b = S$ ，提取其中的 S 的 x 向量作为密钥（预主密钥） 参考资料： TLS/SSL 协议详解 (30) SSL 中的 RSA、DHE、ECDHE、ECDH 流程与区别_Network/Storage/Linux Kernel-CSDN 博客_ecdhe 图解 ECDHE 密钥交换算法 - 小林 coding - 博客园 (cnblogs.com) 问：DHE 算法、 DH 算法、 ECC 算法、ECDHE 算法和 ECDSA 算法，它们有何不同 答：\n​ DH 算法是一种基于离散对数问题的一种密匙交换算法。\n​ DHE 算法为 DH 算法的一种。根据服务端私匙的生成的具体实现方法，DH 算法分为两种：DHE 和 static DH（已废弃）。后者废弃原因为服务端私匙是固定的（静态的），一旦被他人破解，会危害到大量其它会话；前者不一样，前者的 E 表示 ephemeral（临时性的）的意思，每一次会话中服务端的私匙都不固定（临时的），即使被破解，也只影响一个会话，如此实现了前向安全。\n​ ECC 算法是一种椭圆曲线算法，主要应用在证书加密上的算法。\n​ ECDHE 算法即为利用了 ECC 椭圆曲线特性的 DHE 算法，在数学上就是基于椭圆曲线离散对数问题的算法，目的是为了提升 DHE 算法的性能，故也是一种密匙交换算法。\n​ ECDSA 算法是一种椭圆曲线算法，主要应用在数字签名上，是使用椭圆曲线密码（ECC）对数字签名算法（DSA）的模拟。\n参考资料： 图解 ECDHE 密钥交换算法 - 小林 coding - 博客园 (cnblogs.com) 问：DH、DHE 算法中证书里的公匙作用区别？ 答：\n​ 在 DH 算法中，证书公匙的作用是对证书的签名，同时用于对于后面密钥协商中服务端的公匙；在 DHE 算法中，证书公匙仅用于签名，如对证书的签名，而实际两方的密匙协商方法是利用离散对数问题协商，因此对于 DHE 算法，双方交互是服务端需要发送 server key exchange 报文。\n问：SSL 中的密码算法有哪些？ 答：\n​ 在密码算法中大概可以有三种：RSA（大整数的因数分解）、DH（离散对数）、ECC（椭圆曲线）。\n​ RSA 算法在密码中应用广泛，可以进行数字签名、密匙交换、证书公匙加密。\n​ DH 算法常应用在密匙交换中，有 static DH 算法（基本不用）、DHE 算法、ECDH 算法（基本不用）、ECDHE 算法。\n​ ECC 算法常用于密匙交换、证书公匙加密（目前的大势所趋）中，有 ECDH 算法（基本不用）、ECDHE 算法、ECDSA 算法。\n​ 用在密匙交换中的算法有：RSA 、DHE、ECDHE；用在数字签名中的算法有：RSA（包含 MD、SHA 系列）、DSA、ECDSA；用在证书公匙加密的算法有：RSA、ECC。\n问：什么是前向安全性？ 答：\n​ 前向安全性指即使密匙现在暴露了，也不会使得过去的通信信息有暴露的危险。与之相对的有后向安全性，指即使密匙现在暴露了，也不会使得未来的其它的通信信息（非本次通信信道的信息）有暴露的危险。\n参考资料 前（后）向安全性 · Sun Note (gitbooks.io) ","date":"2022-03-04T15:17:06+08:00","permalink":"https://llwh2333.github.io/p/%E5%AD%A6%E4%B9%A0-ssl-/-tls-%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/","title":"学习 SSL / TLS 协议中的问题"}]