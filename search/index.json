[{"content":"官方的 Paymaster.sol 部分\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 // SPDX-License-Identifier: MIT pragma solidity 0.8.20; import \u0026#34;@openzeppelin/contracts/token/ERC20/IERC20.sol\u0026#34;; import \u0026#34;./interfaces/IPaymaster.sol\u0026#34;; import \u0026#34;./interfaces/IPaymasterFlow.sol\u0026#34;; import \u0026#34;./L2ContractHelper.sol\u0026#34;; // 这是个假出纳员。它希望 paymasterInput 包含其“签名”以及所需的汇率 // 仅支持基于授权的 paymaster 流程 contract TestnetPaymaster is IPaymaster { function validateAndPayForPaymasterTransaction( bytes32, bytes32, Transaction calldata _transaction ) external payable returns (bytes4 magic, bytes memory context) { // 默认交易已经被接收（应该是指通过交易验证，指差提供足够的交易费用即可执行） // 应该是函数的函数选择器 magic = PAYMASTER_VALIDATION_SUCCESS_MAGIC; // 只能由系统合约 bootloader 调用 require( msg.sender == BOOTLOADER_ADDRESS, \u0026#34;Only bootloader can call this contract\u0026#34; ); // 输入大于 4 ，因为至少要有函数选择器 require( _transaction.paymasterInput.length \u0026gt;= 4, \u0026#34;The standard paymaster input must be at least 4 bytes long\u0026#34; ); // 获得函数选择器 bytes4 paymasterInputSelector = bytes4( _transaction.paymasterInput[0:4] ); // 检查函数选择器是否对应 approvalBased 函数的函数选择器 if (paymasterInputSelector == IPaymasterFlow.approvalBased.selector) { // While the actual data consists of address, uint256 and bytes data, // the data is not needed for the testnet paymaster // 数据由地址、uint256、字节数据组成，但 testnet 上的 paymaster 并不需要 (address token, uint256 amount, ) = abi.decode( _transaction.paymasterInput[4:], (address, uint256, bytes) ); // 首先检查用户（交易的发起方）是否提供了足够的限额 address userAddress = address(uint160(_transaction.from)); address thisAddress = address(this); uint256 providedAllowance = IERC20(token).allowance( userAddress, thisAddress ); require( providedAllowance \u0026gt;= amount, \u0026#34;The user did not provide enough allowance\u0026#34; ); // 测试网上的 paymaster 用 X wei 的 ETH 交换 X wei 的 token（1：1交换） uint256 requiredETH = _transaction.gasLimit * _transaction.maxFeePerGas; if (amount \u0026lt; requiredETH) { // 虽然条款中明确规定，用户少付了费用给 paymaster 交易将不会被接收（因为这可能会导致交易得不到足够的gas）， // 但我们并不希望交易会 revert，因为对于费用的估计，我们允许用户提供更少数量的资金来维持财产， // 如果使用 X gas 能使交易成功，那么 X+1 gas 同样可以 magic = bytes4(0); } // 从用户处拉取所有的 tokens try IERC20(token).transferFrom(userAddress, thisAddress, amount) {} catch (bytes memory revertReason) { // 如果 revert 原因为空或仅由函数选择器表示，我们将用更用户友好的消息替换错误 //（应该就是让错误更加具有可读性） if (revertReason.length \u0026lt;= 4) { revert(\u0026#34;Failed to transferFrom from users\u0026#39; account\u0026#34;); } else { assembly { revert(add(0x20, revertReason), mload(revertReason)) } } } // bootloader 从不返回任何数据，所以可以安全的忽略 //（这里应该是项 bootloader 转账，提供足够的交易费用） (bool success, ) = payable(BOOTLOADER_ADDRESS).call{ value: requiredETH }(\u0026#34;\u0026#34;); require(success, \u0026#34;Failed to transfer funds to the bootloader\u0026#34;); } else { revert(\u0026#34;Unsupported paymaster flow\u0026#34;); } } function postTransaction( bytes calldata _context, Transaction calldata _transaction, bytes32, bytes32, ExecutionResult _txResult, uint256 _maxRefundedGas ) external payable override { // Nothing to do } receive() external payable {} } 官方的交互示范脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 import { ethers } from \u0026#34;ethers\u0026#34;; import { Provider, Contract, utils, Signer } from \u0026#34;zksync-ethers\u0026#34;; // 希望执行合约的地址，过去部署的 ZeekMessages 合约的地址 const ZEEK_MESSAGES_CONTRACT_ADDRESS = \u0026#34;\u0026#34;; // ERC20 代币的合约地址 const TOKEN_CONTRACT_ADDRESS = \u0026#34;\u0026#34;; // Message to be sent to the contract const NEW_MESSAGE = \u0026#34;This tx cost me no ETH!\u0026#34;; (async () =\u0026gt; { try { // Note that the script needs the ABI which is generated from the compilation artifact. // Make sure contract is compiled and artifacts are generated const messagesContractArtifactsPath = `browser/artifacts/contracts/zksync_first.sol/ZeekMessages.json`; const tokenContractArtifactsPath = `browser/artifacts/contracts/zksync_erc20.sol/TestToken.json`; const messagesContractABI = JSON.parse( await remix.call(\u0026#34;fileManager\u0026#34;, \u0026#34;getFile\u0026#34;, messagesContractArtifactsPath) ); const tokenContractABI = JSON.parse( await remix.call(\u0026#34;fileManager\u0026#34;, \u0026#34;getFile\u0026#34;, tokenContractArtifactsPath) ); console.log(\u0026#34;Sending a transaction via the testnet paymaster\u0026#34;); const browserProvider = new ethers.providers.Web3Provider(web3Provider); const zkProvider = new Provider(\u0026#34;https://sepolia.era.zksync.dev\u0026#34;); // const signer = (new ethers.providers.Web3Provider(web3Provider)).getSigner(0) const zkSigner = Signer.from(browserProvider.getSigner(), zkProvider); // const walletAddress = await signer.getAddress(); const walletAddress = await zkSigner.getAddress(); console.log(walletAddress); // initialise messages and token contracts with address, abi and signer // 初始化合约，通过合约地址、abi、签名者 const messagesContract = new Contract( ZEEK_MESSAGES_CONTRACT_ADDRESS, messagesContractABI.abi, zkSigner ); const tokenContract = new Contract(TOKEN_CONTRACT_ADDRESS, tokenContractABI.abi, zkSigner); // 检索并打印当前钱包余额 let ethBalance = await zkProvider.getBalance(walletAddress); console.log(`Account ${walletAddress} has ${ethers.utils.formatEther(ethBalance)} ETH`); let tokenBalance = await tokenContract.balanceOf(walletAddress); console.log( `Account ${walletAddress} has ${ethers.utils.formatUnits(tokenBalance, 18)} tokens` ); //检索测试网上的 paymaster 地址（应该是官方的示例合约地址） const testnetPaymasterAddress = await zkProvider.getTestnetPaymasterAddress(); console.log(`Testnet paymaster address is ${testnetPaymasterAddress}`); // 获取当前 gas 费用 const gasPrice = await zkProvider.getGasPrice(); console.log(\u0026#34;gasPrice \u0026gt;\u0026gt; \u0026#34;, gasPrice); // 明确 paymaster 的 gas 估计范围 //（应该是测试 1 个 ERC20 token 可代付的 gas 数量） const paramsForFeeEstimation = utils.getPaymasterParams(testnetPaymasterAddress, { type: \u0026#34;ApprovalBased\u0026#34;, token: TOKEN_CONTRACT_ADDRESS, // 设置 minimalAllowance 为 1 来估计 // 授权支出的 erc20 代币数量 minimalAllowance: ethers.BigNumber.from(1), // 空字节，因为测试网 paymaster 不使用 innerInput innerInput: new Uint8Array(0), }); // 通过 paymaster 估计 gasLimit //（估计执行目标函数所需要花费的 gas Limit） const gasLimit = await messagesContract.estimateGas.sendMessage(NEW_MESSAGE, { customData: { gasPerPubdata: utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, paymasterParams: paramsForFeeEstimation, }, }); console.log(\u0026#34;gasLimit \u0026gt;\u0026gt; \u0026#34;, gasLimit); // 使用 ETH 计算的费用将与使用测试网 paymaster 的 ERC20 代币相同 //（计算出所需要的 ETH 费用） const fee = gasPrice * gasLimit; console.log(\u0026#34;Fee \u0026gt;\u0026gt;\u0026#34;, fee); // 新的 paymaster 的参数作为费用的 minimalAllowance（在合约中我们可以看到 token 和 ETH 是 1：1兑换的 ） const paymasterParams = utils.getPaymasterParams(testnetPaymasterAddress, { type: \u0026#34;ApprovalBased\u0026#34;, token: TOKEN_CONTRACT_ADDRESS, // provide estimated fee as allowance minimalAllowance: fee, // empty bytes as testnet paymaster does not use innerInput innerInput: new Uint8Array(0), }); // 完全覆盖对象，包含了 maxFeePerGas 和 maxPriorityFeePerGas //（应该就是使用 paymaster 需要额外添加的交易参数） const txOverrides = { maxFeePerGas: gasPrice, // 为优先打包愿意多付的 gas 费用 maxPriorityFeePerGas: \u0026#34;1\u0026#34;, gasLimit, customData: { gasPerPubdata: utils.DEFAULT_GAS_PER_PUBDATA_LIMIT, paymasterParams, }, }; console.log(\u0026#34;overrides \u0026gt;\u0026gt; \u0026#34;, txOverrides); console.log(`Sign the transaction in your wallet`); // 发送附有 paymaster 参数进行重载的交易 const txHandle = await messagesContract.sendMessage(NEW_MESSAGE, txOverrides); console.log( `Transaction ${txHandle.hash} with fee ${ethers.utils.formatUnits( fee, 18 )} ERC20 tokens, sent via paymaster ${testnetPaymasterAddress}` ); await txHandle.wait(); console.log(`Transaction processed`); ethBalance = await zkProvider.getBalance(walletAddress); tokenBalance = await tokenContract.balanceOf(walletAddress); console.log(`Account ${walletAddress} now has ${ethers.utils.formatEther(ethBalance)} ETH`); console.log( `Account ${walletAddress} now has ${ethers.utils.formatUnits(tokenBalance, 18)} tokens` ); console.log(`Done!`); } catch (e) { console.error(\u0026#34;Error in script!\u0026#34;); console.error(e.message); console.error(e); } })(); ","date":"2024-08-08T17:56:25+08:00","permalink":"http://localhost:1313/p/%E5%AF%B9-zksync-%E5%AE%98%E6%96%B9-paymaster-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E7%9A%84%E7%90%86%E8%A7%A3/","title":"对 zksync 官方 Paymaster 示例代码的理解"}]